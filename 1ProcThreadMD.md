
[СИСТЕМНОЕ ПРОГРАММИРОВАНИЕ В ОС LINUX	3](#_toc190185308)

[Атрибуты процесса	3](#_toc190185309)

[Системные функции порождения процессов	8](#_toc190185310)

[Функции семейства exec()	12](#_toc190185311)

[Функции семейства wait()	16](#_toc190185312)

[Практика планирования	23](#_toc190185313)

[Характеристики квантования	34](#_toc190185314)

[Функции изменения приоритетов	36](#_toc190185315)

[Управление заданиями. Утилиты jobs и fg	39](#_toc190185316)

[Наследование при создании процессов	40](#_toc190185317)

[Взаимодействие родственных процессов	45](#_toc190185318)

[Многонитевое функционирование	49](#_toc190185319)

[Управление процессами и потоками с использованием сигналов	97](#_toc190185320)

[Наследование диспозиции сигналов	146](#_toc190185321)

[Сигналы POSIX реального времени	151](#_toc190185322)

[Характеристики сигналов реального времени	152](#_toc190185323)


















# <a name="_toc190185308"></a>**СИСТЕМНОЕ ПРОГРАММИРОВАНИЕ В ОС LINUX**

# <a name="_toc190185309"></a>**Атрибуты процесса**

В ОС семейства UNIX все процессы могут быть порождены только какими-либо другими процессами. В качестве прародителя всех остальных процессов в разных UNIX-подобных системах могут выступать процессы с идентификатором (PID) 0 или 1. PID (Process ID) – идентификатор процесса (целое  положительное число) – его уникальный атрибут, служащий для распознавания процесса операционной системой, т.е. каждый процесс в ОС получает свой собственный PID. При создании каждого нового процесса ОС пытается присвоить ему следующий по возрастанию свободный номер. Если таких свободных номеров не остается (достигли максимума), то ОС выбирает минимальный из всех свободных. Освобождаются идентификаторы по мере завершения процессов. В ОС Linux присвоемние PID начинается с 0, такой идентификатор получает процесс ядра (kernel) при старте ОС. Максимально возможное значение для PID в Linux на базе процессоров Intel составляет 2^31-1. 

Создание процесса осуществляется в два этапа. На первом этапе формируются необходимые структуры данных для идентификации процесса и дальнейшего предоставления ему необходимых ресурсов. ОС строит образ порожденного процесса, являющийся копией образа породившего процесса, то есть дублируются дескриптор, контекст и образ процесса. Часть дескриптора заполняется новыми значениями. Сегмент данных и сегмент стека родительского процесса копируются на новое место, образуя сегменты данных и стека процесса-потомка. В большинстве систем кодовый сегмент копируется только тогда, когда он не является разделяемым. В противном случае процесс-потомок становится еще одним процессом, разделяющим данный кодовый сегмент. (Ниже будут приведены эксперименты, подтверждающие это). Атрибут идентификации порождающего процесса – PPID (Pairant Process ID).

На втором этапе создания процесса осуществляется заполнение содержимого контекста, загрузка исполняемого кода (файла) новой программы, коррекция дескриптора и запуск новой программы (кода) на исполнение. Несмотря на то, что после завершения второй фазы порождения процесса это полностью самостоятельный процесс со своими кодом, стеком, данными, операционной средой и ресурсами, порожденный процесс-потомок и породивший его процесс-родитель остаются связанными между собой до конца жизненного цикла кого-либо из них. Таким образом, выстраивается дерево процессов. Более того, на каждом этапе создания процесса формируется свой набор атрибутов и ресурсов, наследуемых потомком от родителя. 

Когда процесс-родитель завершает свою работу до завершения процесса-потомка, PPID потомка меняет свое значение на 1, соответствующее PID процесса init, время жизни которого определяется  временем функционирования ОС. Информацию о процессах: дереве процессов, значениях атрибутов каждого из процессов, временной статистике и др. можно оперативно получить с помощью утилит, наиболее информативной из которых является утилита ps (Process Status). (Более подробно ознакомиться с возможностями утилиты можно в manual той системы, с которой работаете. Здесь будем ее использовать для наглядности и упрощения кода в примерах программ).

*Системные процессы* являются частью ОС, в частности, ядра. Процессы ядра не имеют соответствующих им программ в виде исполняемых файлов, размещаются в оперативной памяти и запускаются при инициализации ядра системы. Находясь в памяти резидентно, часть системных процессов «постоянно» активны и выполняются циклически, а часть активизируется на выполнение по запросам от других системных процессов или приложений. 

Узнать, какие системные процессы сейчас запущены, можно проанализировав флаги (поле F), установленные процессу упомянутой выше утилитой ps. Логическая сумма двух восьмиричных разрядов отображает системный статус процесса следующим образом:


|Флаг|Информация о процессе|
| :- | :- |
|<p>00 </p><p>01 </p><p>02 </p><p>04 </p><p>08 </p><p>10 </p><p>20 </p><p>40 </p><p>80 </p>|<p>процесс терминирован, элемент таблицы процессов свободен</p><p>системный процесс, постоянно в оперативной памяти </p><p>процесс трассируется родительским процессом</p><p>процесс остановлен трассировочным сигналом родителя, родитель в ожидании</p><p>процесс не может быть разбужен сигналом</p><p>процесс в основной памяти</p><p>процесс в основной памяти, блокирован до завершения события</p><p>идет сигнал к удаленной системе</p><p>процесс в очереди на вывод</p>|

Таким образом, нечетное значение флага свидетельствует о том, что процесс – системный. 

Приведем несколько примеров.

user@debian:~/OS/Lab3/$ ps axfo pid,ppid,f,stat,cmd

`  `PID   PPID 	F	STAT 	 CMD

`    `2      0 		1 	S   	 [kthreadd]

`    `3      2 		1 	S    	 \\_ [ksoftirqd/0]

`    `6      2 		1 	S    	 \\_ [migration/0]

`    `7      2 		5 	S     	 \\_ [watchdog/0]

`   `21     2 		1 	S<   	 \\_ [cpuset]

`   `22     2 		1 	S<   	 \\_ [khelper]

`   `23     2 		5 	S    	 \\_ [kdevtmpfs]

`   `24     2 		1 	S<   	 \\_ [netns]

`   `25     2 		1 	S     	 \\_ [sync\_supers]

`   `26     2 		1 	S    	 \\_ [bdi-default]

...

`  `547     2 	1 	S<    	 \\_ [kpsmoused]

`  `551     2 	1 	S<   	 \\_ [led\_workqueue]

`  `558     2 	1 	S<   	 \\_ [hd-audio0]

` `1515    2		1 	S     	 \\_ [jbd2/sda6-8]

` `1516    2 	1 	S<   	 \\_ [ext4-dio-unwrit]

` `1851    2 	1 	S<    	\\_ [rpciod]

` `1853    2 	1 	S<    	\\_ [nfsiod]

` `2214    2 	1 	S     	\\_ [flush-8:0]

` `2553    2 	5	S<    	\\_ [krfcommd]

` `3644    2 	1 	S     	\\_ [kauditd]

...

` `4354     1 	1	 Sl   /usr/bin/gnome-keyring-daemon --daemonize --login

` `4415     1	1 	 S    /usr/bin/dbus-launch --exit-with-session x-session-manager

Первые PID всегда зарезервированы под системные процессы, что логично, т.к. именно они первыми порождаются в системе при ее запуске.

Конвейер   ps -ecf | more   позволяет увидеть все запущенные процессы. Приведем некоторую выборку из них (поля  CLS PRI  отражают политику планирования и приоритет процессов):

user@debian:~/OS/Lab3/$ ps -ecf

UID        PID  PPID CLS PRI    STIME TTY   TIME CMD

root         1     0 	TS   19 	07:10 ?        00:00:01 init [2]  

root         2     0 	TS   19 	07:10 ?        00:00:00 [kthreadd]

root         3     2 	TS   19	 07:10 ?        00:00:00 [ksoftirqd/0]

root         6     2 	FF  139	 07:10 ?        00:00:00 [migration/0]

root         7     2 	FF  139 	07:10 ?        00:00:00 [watchdog/0]

root        21     2 	TS   39 	07:10 ?        00:00:00 [cpuset]

root        22     2 	TS   39 	07:10 ?        00:00:00 [khelper]

root        23     2 	TS   19 	07:10 ?        00:00:00 [kdevtmpfs]

root        24     2 	TS   39 	07:10 ?        00:00:00 [netns]

root        25     2 	TS   19 	07:10 ?        00:00:00 [sync\_supers]

root        26     2 	TS   19 	07:10 ?        00:00:00 [bdi-default]

root        27     2 	TS   39 	07:10 ?        00:00:00 [kintegrityd]

root        28     2 	TS   39	 	07:10 ?        00:00:00 [kblockd]

root        32     2 	TS   19 	07:10 ?        00:00:00 [khungtaskd]

root        33     2 	TS   19 	07:10 ?        00:00:00 [kswapd0]

root        34     2 	TS   14 	07:10 ?        00:00:00 [ksmd]

root        35     2 	TS    0 		07:10 ?        00:00:00 [khugepaged]

root        36     2 	TS   19 	07:10 ?        00:00:00 [fsnotify\_mark]

root        37     2 	TS   39 	07:10 ?        00:00:00 [crypto]

root       138    2 	TS   19 	07:10 ?        00:00:00 [khubd]

Для ОС, рассматриваемой в примере (Linux – debian), при запуске процесса 0 порождаются 2 процесса: init и kthreadd. При этом все системные процессы являются потомками диспетчера потоков, а прикладные службы и демоны являются потомками init.

Важными атрибутами процесса являются *идентификаторы пользователя процесса*. Реальный и эффективный идентификаторы пользователя (UID и EUID) процесса отражают соответствие этого процесса определенному пользователю. Реальные идентификатоы совпадают с идентификаторами пользователя, который запустил процесс, а эффективный — свидетельствует о том, от чьего имени он был запущен. Права доступа процесса к ресурсам ОС UNIX определяются эффективными идентификаторами. Если в маске прав исполняемого файла будет установден бит SUID, то процесс будет обладать правами владельца исполняемого файла. Для управления процессом (например, посредством kill) используются реальные идентификаторы. Все идентификаторы наследуются потомком от родителя. Множество допустимых значений UID зависит от выбранной системы. В общем случае для UID допускается использование значений от 0 до 65535 и требуется соблюдение следующих правил:

UID суперпользователя всегда равен нулю (UID = 0);

пользователю nobody обычно присваивается или наибольший из возможных UID, или один из системных UID

(nobody – имя пользователя, не являющегося владельцем ни одного файла, не состоящего ни в одной привилегированной группе и не имеющего никаких полномочий, кроме стандартных для обычных пользователей);

UID в диапазоне от 1 до 100, как правило, резервируются на системные нужды (некоторые системы рекомендуют резервировать UID с 101 по 499, или 999).

Чтобы определить UID процесса, можно опять воспользоваться утилитой ps.

В примере ниже показано использование EUID (эффективного UID) :

$ ls -l myprog

-rwsr-sr-x 1 root root 6073 Дек  15  12:01 myprog

из вывода результата выполнения команды ls следует, что владельцем файла является суперпользователь, однако установленный бит SUID, позволяет запускать этот файл и другим пользователям от имени root.

С помощью команды 

ps afo ruid,euid,pid,tty,stat,cmd 

можно увидеть реальный и эффективный uid процесса, его pid, ассоциируемый с ним терминал, состояние процесса, и имя исполняемого кода:

$ ./myprog &

$ ps afo ruid,euid,pid,tty,stat,cmd

RUID   EUID   PID    TT       STAT   CMD

1000     1000    4556   pts/0    Ss        bash

1000     0          6999   pts/0    S          \\_ ./ myprog

1000     1000    7005   pts/0    R+       \\_ ps afo ruid,euid,pid,tty,stat,cmd

Таким образом, процесс, выполняющий программу myprog, запущен обычным пользователем с uid =1000 от имени процесса с uid=0, т.е. процесса суперпользователя.

# <a name="_toc190185310"></a>**Системные функции порождения процессов**

Основная системная функция, в результате которой выполняются все перечисленные ранее действия первого этапа порождения процесса – fork(). После выполнения системного вызова fork оба процесса продолжают выполнение с одной и той же точки. fork возвращает в породивший процесс идентификатор порожденного процесса, а в порожденный процесс — NULL. Приведем общую структуру программы для демонстрации «распараллеливания» вычислений за счет порождения еще одного процесса посредством fork():

#include <stdio.h>

int main()

{

`    `int pid, n;

`    `pid = fork();

`    `if (pid == -1)

`    `{

`		`error("fork");

`		`exit(1);

`    `}

`    `if (pid == 0)  {

`		    `printf("new pid = %d, ppid =%d \n", getpid(),getppid() ); 

/\*здесь размещаются вычисления, выполняемые процессом-потомком \*/

`			`…

`			`}

`    `else	               {

`		    `printf("parent pid = %d, ppid =%d \n", getpid(),getppid() ); 

/\*здесь размещаются вычисления, выполняемые порождающим процессом \*/

`			`…

`			`}

`    `printf("Завершение процесса\n");

`    `exit(1);

}

В результате выполнения программы будут выведены идентификаторы каждого процесса и его родителя, а также дважды фраза «Завершение процесса», что свидетельствует об исполнении одного и того же кодового сегмента обоими процессами. Распараллеливание – условное, если оба процесса выполняются на одном процессоре или ядре (т.е. в режиме разделения времени при многозадачности).

Если однократные вычисления в этом коде заменить на циклическое исполнение, то можно будет наблюдать конкуренцию процессов за процессорный ресурс. 

#include <stdio.h>

int main()

{

`    `int pid, n;

`    `pid = fork();

`    `if (pid == -1)

`    `{

`		`error("fork");

`		`exit(1);

`    `}

while(1)

`   `{  	

`    `if (pid == 0)

`		`{ printf("new pid = %d, ppid =%d \n", getpid(),getppid() ); 

/\*здесь размещаются вычисления, выполняемые процессом-потомком \*/

`		`}

`    `else

`		`{  printf("parent pid = %d, ppid =%d \n", getpid(),getppid() ); 

/\*здесь размещаются вычисления, выполняемые порождающим процессом \*/

`		`}

`    `}

`    `printf("Завершение процесса\n");

`    `exit(1);

}

Но следует учитывать, что использование функций подобных printf(), sleep() или system() будут приводить к передаче управления другому процессу, при этом порядок исполнения может не соответствовать порядку вывода на терминал или в файл, а порядок исполнения в соответствии с выбранной процедурой планирования тоже может быть нарушен. Для получения более точных результатов необходимо создавать программы так, чтобы по мере их исполнения информация накапливалась в структурах данных в ОЗУ, а по окончании экспериментов скачивалась в файл или на терминал. Кроме того, целесообразно использовать системные возможности журналирования событий.

Ниже приведен исходный код с псевдораспараллеливанием вычислений. Программа выполняет вызов fork(), выводит идентификатор выполняющегося процесса. В случае, если текущий процесс – потомок (pid = 0), то производится 1000 операций инкрементации переменной n, иначе (текущий процесс – родитель) – 1000 операций декремента переменной m. После завершения вычислений, выводится результат и сообщение о завершении вычислений.

#include <stdio.h> 

#include <math.h> 

#include <sys/resource.h> 

void main(int argc, char\* argv[]) 

{ 

`	`int m, n, pid;  

`	`m=5000;

`	`n=1;

`	`pid = fork(); 

`	`if(pid == -1) 

`	`{ 

`		`perror("fork error"); 

`		`exit(1); 

`	`} 

`	`printf("pid=%i\n",pid); 

`	`if(pid != 0) 

`	`{

`		`int j;  

`		`for(j = 1; j <= 1000; j++) 

`		`{ 

`			`m-=1; 

`		`} 

`			`printf("родитель: %i\n\n",m);

`	`} 	

`	`else 

`	`{ 

`		`int i; 

`		`for(i = 1; i <= 1000; i++) 

`		`{

`			`n+=1;

`		`}

`		`printf("потомок: %d\n\n",n); 

`	`}  

`	`printf("Программа завершена\n"); 

`	`exit(1); 

}

Результат работы программы:

pid=28786

родитель: 4000

Программа завершена

pid=0

потомок: 1001

Программа завершена

<a name="_toc190185311"></a>**Функции семейства exec()**

*На втором этапе создания процесса* осуществляется заполнение содержимого  контекста, загрузка исполняемого кода новой программы, коррекция дескриптора и запуск новой программы на исполнение. Используется при этом какая-либо из функций семейства exec().** 

Функции семейства exec() имеют следующие прототипы:

int execlp(const char \*file,const char \*arg0,…const char \*argN,(char \*)NULL );
int execvp(const char \*file, char \*argv[]);
int execl(const char \*path,const char \*arg0,…const char \*argN, (char \*)NULL );
int execv(const char \*path, char \*argv[]);
int execle(const char \*path, const char \*arg0,…const char \*argN,(char \*)NULL, 

`                 `char   \*envp[]);
int execve(const char \*path, char \*argv[], char \*envp[])

и отличаются принимаемыми аргументами, на что указывает суффикс в названии. Суффиксы l, v, p, e , а также их сочетания в именах функций определяют формат и объем аргументов, а также каталоги, в которых нужно искать загружаемую программу:

l (список) – аргументы командной строки передаются в форме списка arg0, arg1.... argN, NULL. Эту форму используют, если количество аргументов известно;

v (vector) – аргументы командной строки передаются в форме вектора argv[]. Отдельные аргументы адресуются через argv [0], argv [1]... argv [n]. Последний аргумент (argv [n]) должен быть указателем NULL;

p (path) – обозначенный  по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды PATH;

e (среда или окружение) – функция ожидает список переменных окружения в виде вектора (envp []).

Для демонстрации использования разных функций семейства можно использовать программу execs.c, в которой на примере подходящей утилиты (с возможностью введения различных ключей и входных параметров) показать различия и возможности всех функций семейства. Здесь приведен упрощенный вариант на примере хорошо знакомой и понятной утилиты ls. 

#include <unistd.h>
#include <stdlib.h>
int main(int argc, char \* argv[]) {
`	`char\* file = "ls"; сhar\* path = "/bin/ls";
`	`char \*args[] = {"ls", "-l", NULL };	char \* env[] = { (char\*)NULL };
`	`if ((int pid = fork()) == 0) {
`		`switch ( (int)argv[1][0] ) {
`		`case (int)'1':
`		  `execl("/bin/ls", "/bin/ls", "-l", (char \*)NULL);break;
`		`case (int)'2':
`		  `execlp("ls", "ls", "-l", (char \*)NULL); break;
`		`case (int)'3':
`		  `execle("/bin/ls", "ls", "-l", (char \*)NULL, envp); break;
`		`case (int)'4':
`		  `execv("/bin/ls", args); break;
`		`case (int)'5':
`		  `execvp("ls", args); break;
`		`case (int)'6':	  
`		  `execvpe("ls", args, (char \*)NULL, env);  break;
`		`}
`	`}
}

Запуская программу с параметром – от 1 до 6, можно задать, какая функция из семейства exec будет использоваться. Пример запуска:

$ ./exec.out 1
$ total 44
-rw-rw-r-- 1 user user  689 нояб. 19 22:43 exec.c
-rwxrwxr-x 1 user user 8820 нояб. 19 22:37 exec.out

Теперь в качестве запускаемой программы рассмотрим собственный код. Родительский процесс с исходным кодом в файле father.c порождает процесс-потомок с помощью функции fork(). Затем, с помощью функции execl("son","son",NULL); запускается исполняемый файл son, выполнение начинается с точки входа – функции main. При этом фиксируются идентификаторы запущенных процессов, а также состояние таблицы процессов в файле file.txt. Родительский процесс дожидается выполнения потомка с помощью команды wait(&status), а статус завершения этого процесса записывается по адресу &status.

Father.c

#include <stdio.h>

int main()

{

`    `int pid, ppid, status;

`    `pid=getpid();

`    `ppid=getppid();

`    `printf("\n\nFATHER PARAM: pid=%i  ppid=%i\n", pid,ppid);

`    `if(fork()==0)

`		`execl("son","son", NULL);

`    `system("ps xf > file.txt");

`    `wait(&status);

`    `printf("\n\nChild proccess is finished with status %d\n\n", status);

`    `return 0;

}

son.c

#include <stdio.h>

int main()

{

`	`int pid,ppid;

`	`pid=getpid();

`	`ppid=getppid();

`	`printf("\n\nSON PARAMS:  pid=%i  ppid=%i\n\n",pid,ppid);

`	`sleep(15);

`	`//exit(1); статус завершения 256

`	`return 0;  // статус завершения 0  

}

Пример выполнения:

FATHER PARAM: pid=7471  ppid=5750

SON PARAMS:  pid=7472  ppid=7471

Child proccess is finished with status 0

В соответствии с выводимыми идентификаторами родителем процесса son является процесс father. Эти же параметры записываются в файл в результате выполнения команды 

ps –xf  (строка программы  system("ps xf > file.txt"); ):

`  `PID TTY      STAT   TIME COMMAND

` `…

` `5750 pts/0    Ss     0:00  |   |   \\_ bash

` `7471 pts/0    S+     0:00  |   |       \\_ ./father

` `7472 pts/0    S+     0:00  |   |           \\_ son

` `7473 pts/0    S+     0:00  |   |           \\_ sh -c ps xf > file.txt

` `7474 pts/0    R+     0:00  |   |               \\_ ps xf

` `…

Назначение полей:

PID — идентификатор процесс

TTY — терминал, с которым связан данный процес

STAT — состояние, в котором на данный момент находится процесс-родитель

TIME — процессорное время, занятое этим процессом

COMMAND — команда, запустившая данный процесс-отец

Состояния STAT, представленные выше:

S : процесс ожидает (т.е. спит менее 20 секунд)

s : лидер сессии

R : процесс выполняется в данный момент

+: порожденный процесс

При запуске «родителя» в фоновом режиме, таблица процессов покажет следующую статистику:

…

5750 pts/0    Ss     0:00  |   |   \\_ bash

7736 pts/0    S      0:00  |   |       \\_ ./father

7737 pts/0    S      0:00  |   |       |   \\_ son

7743 pts/0    R+     0:00  |   |       \\_ ps -xf

…

Командный интерпретатор (в данном случае bash) запускает программу ./father, «распараллеливает» процессы и порождает son. Программа запускается в фоновом режиме, а параллельно ей — команда ps -xf. Обратите внимание, что при однократном запуске от father запускается еще один экземпляр интерпретатора, который в свою очередь запускает утилиту ps (*Process Status*)

По завершении программы father.c :

` `…

5750 pts/0    Ss     0:00  |   |   \\_ bash

7744 pts/0    R+     0:00  |   |       \\_ ps -xf

…

[1]+  Done                    ./father

При очередном вызове команды ps -xf добавляется строчка, информирующая о завершении выполнения команды father.c.

## <a name="_toc190185312"></a>**Функции семейства wait()**

Прототипы функций рассматримаемого семейства:

#include <sys/types.h>

#include <wait.h>

pid\_t wait(int \*status);

pid\_t waitpid(pid\_t pid, int \*status, int options);

int waitid(idtype\_t idtype, id\_t id, siginfo\_t \* infop , int options );

Более подробно остановимся на выполнени команды wait(&status). При успешном завершении системного вызова fork процессы порождающий и порожденный равноправно сосуществуют в системе. Они выполняются, разделяя процессорное время, конкурируя за ресурсы на основе своих приоритетов. Выполнение порождающего процесса может быть приостановлено до завершения потомка системным вызовом wait. Системный вызов wait возвращает родителю идентификатор того потомка, который завершился первым после последнего обращения к wait. Если у родителя несколько потомков, то чтобы узнать о завершении каждого из них, нужно выполнить несколько системных вызовов wait с проверкой их возвращаемых значений. Если процесс не имеет потомков, wait возвращает код (-1).

`      `Системный вызов waitpid() блокирует выполнение текущего процесса до тех пор, пока либо не завершится порожденный им процесс, определяемый значением параметра pid, либо пока текущий процесс не получит сигнал, для которого установлена реакция по умолчанию "завершить процесс" или реакция обработки пользовательской функцией. Если порожденный процесс, заданный параметром pid, уже в стадии завершения к моменту системного вызова управление немедленно возвращается без блокирования текущего процесса.

Параметр pid определяет порожденный процесс, завершения которого дожидается процесс-родитель, следующим образом:

\- если pid > 0 ожидаем завершения процесса с идентификатором pid;

\- если pid = 0, то ожидаем завершения любого порожденного процесса в группе, к которой принадлежит процесс-родитель;

\- если pid = -1, то ожидаем завершения любого порожденного процесса;

\- если pid < 0, но не (-1), то ожидаем завершения любого порожденного процесса из группы, идентификатор которой равен абсолютному значению параметра pid.

Значение *options* создается путем логического сложения нескольких констант, в частности WNOHANG, WUNTRACED.

WNOHANG означает немедленное возвращение управления, если ни один из потомков не завершил выполнение. Вызов с установленной опцией WNOHANG вернет значение 0, если потомок, специфицированный параметром pid существует, но еще не завершился. 

WUNTRACED означает возврат управления и для остановленных (но не отслеживаемых) потомков, о статусе которых еще не было сообщено. Статус для отслеживаемых остановленных подпроцессов обеспечивается и без этой опции.

Функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает *status*, если *status* не равен NULL. Этот статус можно проверить с помощью макросов. Некоторые из них используются в паре при условии возвращения предусмотренного значения.

`    `WIFEXITED(*status*) не равно нулю, если потомок успешно завершился.

WEXITSTATUS(*status*) возвращает восемь младших битов значения, которое вернул завершившийся потомок. Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main(). Этот макрос можно использовать, только если макрос WIFEXITED вернул ненулевое значение.

`    `WIFSIGNALED(*status*) возвращает истинное значение, если потомок завершился из-за необработанного сигнала.

WTERMSIG(*status*) возвращает номер сигнала, который привел к завершению дочернего процесса. Этот макрос можно использовать, только если WIFSIGNALED вернул ненулевое значение.

`    `WIFSTOPPED(*status*) возвращает истинное значение, если потомок, из-за которого функция вернула управление, в настоящий момент остановлен.

WSTOPSIG(*status*) возвращает номер сигнала, из-за которого потомок был остановлен. Этот макрос можно использовать, только если WIFSTOPPED вернул ненулевое значение.

waitid()

Системный вызов* waitid() предоставляет более полный контроль над тем, какого изменения состояния и какого из потомков следует ожидать

int waitid(idtype\_t *idtype*, id\_t *id*, siginfo\_t \* infop , int options );

аргументы *idtype* и *id* определяют, какого потомка или потомков отслеживать: 
*idtype* == P\_PID  – потомка, чей ID процесса совпадает с *id*.

*idtype* == P\_PGID – любого  потомка, чей ID группы процессов совпадает с *id*.

*idtype* == P\_ALL – любого потомка; значение *id* игнорируется.

Ожидаемые (отслеживаемые) изменения состояния потомков задаются флагами в *options* (флаги объединяются через OR):

|флаг|назначение|
| :- | :- |
|WEXITED|ждать завершения потомков|
|WSTOPPED|выявить потомков, которые завершатся по получению сигнала|
|WCONTINUED|ждать возобновления работы потомков (ранее остановленных) при получении сигнала SIGCONT|
|Дополнительные флаги задаются также с помощью OR в *options*||
|WNOHANG|аналогично waitpid()|
|WNOWAIT|не передавать управление потомку (оставить его в состоянии ожидания); следующий вызов wait сможет снова получить информацию о его состоянии|

При успешном возврате, waitid() заполняет следующие поля в структуре *siginfo\_t*, указываемой из *infop*:

<table><tr><th valign="top">поле</th><th colspan="2" valign="top">значение</th></tr>
<tr><td valign="top"><i>si_pid</i></td><td colspan="2" valign="top">ID процесса потомка</td></tr>
<tr><td valign="top"><i>si_uid</i></td><td colspan="2" valign="top">реальный пользовательский ID потомка</td></tr>
<tr><td valign="top"><i>si_signo</i></td><td colspan="2" valign="top">всегда устанавливается в SIGCHLD</td></tr>
<tr><td valign="top"><i>si_status</i></td><td colspan="2" valign="top">заполняется кодом завершения потомка, заданном в exit(), или номером сигнала, который прервал, остановил или продолжил работу потомка. Содеримое поля можно определить по значению поля <i>si_code</i></td></tr>
<tr><td rowspan="7" valign="top"><p><i>si_code</i></p><p></p><p></p></td><td colspan="2" valign="top">устанавливается в одно из значений:</td></tr>
<tr><td valign="top">CLD_EXITED</td><td valign="top">потомок вызвал exit()</td></tr>
<tr><td valign="top">CLD_KILLED</td><td valign="top">потомок завершил работу по сигналу</td></tr>
<tr><td valign="top">CLD_DUMPED</td><td valign="top">потомок завершил работу по сигналу, и был создан дамп памяти</td></tr>
<tr><td valign="top">CLD_STOPPED</td><td valign="top">потомок приостановлен по сигналу</td></tr>
<tr><td valign="top">CLD_TRAPPED</td><td valign="top">трассируемый потомок был захвачен</td></tr>
<tr><td valign="top">CLD_CONTINUED</td><td valign="top">потомок продолжил работу по сигналу SIGCONT</td></tr>
</table>

Если в *options* указан флаг WNOHANG и нет потомков в ожидаемом состоянии, то waitid() сразу возвращает 0, а состояние структуры *siginfo\_t*, на которую указывает *infop*, неопределённо. Чтобы отличать этот случай от того, где потомок был в ожидаемом состоянии, необходимо обнулить поле *si\_pid* перед вызовом и проверить ненулевое значение в этом поле после отработки вызова.

Приведем примеры кода с использованием описанных функций:

son1.c,  son2.c, son3.c  

с различными функциями завершения и ожидаемым статусом завершения

#include <stdio.h>

int main()

{

`	`int pid,ppid;

`	`pid=getpid();

`	`ppid=getppid();

`	`printf("\nSON PARAMS:  pid=%i  ppid=%i\n",pid,ppid);

`	`sleep(15);

`	   `**return 0;**

`	`**// exit(1);**

`	`**// exit(-1);**

}

father 1.c

#include <stdio.h>

#include <sys/types.h>

#include <wait.h>

int main()

{

`    `int i, pid[4], ppid, status, result;

`   `pid[0]=getpid();

`    `ppid=getppid();

`    `printf("\nFATHER PARAMS: pid=%i  ppid=%i\n", pid[0],ppid);

`   `if((pid[1] = fork()) == 0)

`		`execl("son1", "son1", NULL);

`    `if((pid[2] = fork()) == 0)

`		`execl("son2", "son2", NULL);

`    `if((pid[3] = fork()) == 0)

`		`execl("son3", "son3", NULL);

`    `system("ps xf > file.txt");

`	`for (i = 1; i < 4; i++)

`	`{

`		`result = **waitpid**(pid[i], &status, **WUNTRACED**);	

printf("\n%d) Child proccess with pid = %d is finished with status %d\n", i, result, status);

`	`}	

`	`return 0;

}

Пример результата работы  программы

Содержимое file.txt:

` `4701 pts/0    Ss     0:00  |       \\_ bash

` `5551 pts/0    S+     0:00  |           \\_ ./father

` `5552 pts/0    S+     0:00  |               \\_ son1

` `5553 pts/0    S+     0:00  |               \\_ son2

` `5554 pts/0    S+     0:00  |               \\_ son3

` `5555 pts/0    S+     0:00  |               \\_ sh -c ps xf > file.txt

` `5556 pts/0    R+     0:00  |                   \\_ ps xf

user@debian:~/OS/Lab3/$ ./father

FATHER PARAMS: pid=5551  ppid=4701

SON PARAMS:  pid=5554  ppid=5551

SON PARAMS:  pid=5553  ppid=5551

SON PARAMS:  pid=5552  ppid=5551

\1) Child proccess with pid = 5552 is finished with status 0

\2) Child proccess with pid = 5553 is finished with status 256

\3) Child proccess with pid = 5554 is finished with status 65280

Father 2.c       для исследования с различными флагами функции waitpid ()

#include <stdio.h>

#include <sys/types.h>

#include <wait.h>

#include <string.h>

int main()

{

`	`int i, ppid, pid[4], status[3], result[3];

`	`char \*son[] = {"son1", "son2", "son3"};

`	`int **option**[] = {**WNOHANG, WUNTRACED, WNOHANG**};

`			`// здесь можно задавать различные флаги исполнения 

`    `pid[4] = getpid();

`    `ppid = getppid();

`    `printf("FATHER PARAMS: pid=%i  ppid=%i\n", pid[3],ppid);

`	`for (i = 0; i < 3; i++)

`    	`if((pid[i] = fork()) == 0)

`			`execl(son[i], son[i], NULL);

`    `system("ps xf > file.txt");

`	`for (i = 0; i < 3; i++)

`	`{

`		`result[i] = **waitpid**(pid[i], &status[i], **option**[i]);	

`		`printf("%d) Child with pid = %d is finished with status %d\n", (1 + i), result[i], status[i]);

`	`}

`	`for(i = 0; i < 3; i++)	

`		`if (**WIFEXITED**(status[i]) == 0)

`			`printf("Proccess pid = %d was failed.\n", pid[i]);

`		`else

`			`printf("Proccess pid = %d was success.\n", pid[i]);

`	`return 0;

}

Примеры результатов с разными комбинациями флагов

**WNOHANG, WUNTRACED, WNOHANG**

FATHER PARAMS: pid=-1218095851  ppid=4701

SON PARAMS:  pid=7923  ppid=7921

SON PARAMS:  pid=7924  ppid=7921

SON PARAMS:  pid=7922  ppid=7921

\1) Child with pid = 0 is finished with **status -1080478072** 

//потомок не успевает завершиться

\2) Child with pid = 7923 is finished with status 512

\3) Child with pid = **0 is finished with status 1**

Proccess pid = 7922 was failed.

Proccess pid = 7923 was success.

Proccess pid = 7924 was failed.


155

**WUNTRACED, WUNTRACED, WUNTRACED:**

FATHER PARAMS: pid=7977  ppid=4701

SON PARAMS:  pid=7978  ppid=7977

SON PARAMS:  pid=7980  ppid=7977

SON PARAMS:  pid=7979  ppid=7977

\1) Child with pid = 7978 is finished with status 0

\2) Child with pid = 7979 is finished with status 512

\3) Child with pid = 7980 is finished with status 65280

Proccess pid = 7978 was success.

Proccess pid = 7979 was success.

Proccess pid = 7980 was success.

**WNOHANG, WUNTRACED, WUNTRACED**:   

FATHER PARAMS: pid=7993  ppid=4701

SON PARAMS:  pid=7996  ppid=7993

SON PARAMS:  pid=7995  ppid=7993

SON PARAMS:  pid=7994  ppid=7993

\1) Child with pid = 0 is finished with status -1075658328

\2) Child with pid = 7995 is finished with status 512

\3) Child with pid = 7996 is finished with status 65280

Proccess pid = 7994 was failed.

Proccess pid = 7995 was success.

Proccess pid = 7996 was success.






# <a name="_toc190185313"></a>**Практика планирования**

Приведем прототипы системных функций, позволяющих считывать и устанавливать политики планирования и соответствующие им параметры:

#include <[sched.h](C:\Users\user\I:\usr\include\sched.h)>

int sched\_setscheduler(pid\_t *pid*, int *policy*, const struct sched\_param \**p*);

int sched\_getscheduler(pid\_t *pid*);

struct sched\_param {

...

`    `int *sched\_priority*;

...

};

Функция sched\_setscheduler устанавливает алгоритм и параметры планирования процесса с номером *pid*. Если *pid* равен нулю, то будет задан алгоритм вызывающего процесса. Тип и значение аргумента *p* зависят от алгоритма планирования. 

Сегодня в Unix подобных ОС, в частности в Linux, и других ОС, следующих стандарту POSIX, поддерживаются *три базовые политики планирования*: *SCHED\_FIFO*, *SCHED\_RR*, и *SCHED\_OTHER*: одна для обычных процессов и две для процессов «реального» времени. Их реализация обеспечивается ядром, а точнее, планировщиком. Каждому процессу присваивается статический приоритет *sched\_priority*, который можно изменить только при помощи системных вызовов. Ядро хранит в памяти списки всех работающих процессов для каждого возможного значения *sched\_priority*, а это значение может находиться в определенном интервале, заданном для данной конкретной реализации ОС. Для того, чтобы определить, какой процесс будет выполняться следующим, планировщик ищет непустой список (очередь) с наибольшим статическим приоритетом и запускает первый процесс из этого списка.

` `Алгоритм планирования определяет, как процесс будет добавлен в список-очередь с тем же статическим приоритетом, и как он будет перемещаться внутри этого списка. *SCHED\_OTHER* – это используемый *по умолчанию* алгоритм *со стандартным разделением времени*, с которым работает большинство процессов. *SCHED\_FIFO* и *SCHED\_RR* предназначены для процессов, которым необходим более четкий контроль над порядком исполнения процессов. Для каждой политики – свои значения и диапазон статических приоритетов, которые могут зависеть от конкретного типа системы, с которой вы работаете. Например, для Linux Debian cтатический приоритет процессов с алгоритмом *SCHED\_OTHER* равен нулю, а статические приоритеты процессов с алгоритмами *SCHED\_FIFO* и *SCHED\_RR* могут находиться в диапазоне от 1 до 99. Статический приоритет, больший, чем 0, может быть установлен только у суперпользовательских процессов, то есть только эти процессы могут иметь алгоритм планировщика *SCHED\_FIFO* или *SCHED\_RR*. 

Для того, чтобы узнать возможный диапазон значений статических приоритетов данного алгоритма планировщика, необходимо использовать функции sched\_get\_priority\_min и sched\_get\_priority\_max. Планирование является упреждающим: если процесс с большим статическим приоритетом готов к запуску, то текущий процесс будет приостановлен и помещен в соответствующий список ожидания. Политика планирования определяет лишь поведение процесса в очереди (списке) работающих процессов с тем же статическим приоритетом.  

1) <a name="_toc190183779"></a>SCHED\_FIFO: планировщик FIFO (First In-First Out)

   Алгоритм *SCHED\_FIFO* можно использовать только со значениями статического приоритета, большими нуля. Это означает, что если процесс с алгоритмом *SCHED\_FIFO* готов к работе, то он сразу запустится, а все обычные процессы с алгоритмом *SCHED\_OTHER* будут приостановлены. *SCHED\_FIFO* - это простой алгоритм без квантования времени. Процессы, работающие согласно алгоритму *SCHED\_FIFO* подчиняются следующим правилам: процесс с алгоритмом *SCHED\_FIFO*, приостановленный другим процессом с большим приоритетом, останется в начале очереди процессов с равным приоритетом, и его исполнение будет продолжено сразу после того, как закончатся процессы с большими приоритетами. Когда процесс с алгоритмом *SCHED\_FIFO* готов к работе, он помещается в конец очереди процессов с тем же приоритетом. 

   Вызов функции sched\_setscheduler или sched\_setparam, который посылается процессом под номером *pid* с алгоритмом *SCHED\_FIFO* приведет к тому, что процесс будет перемещен в конец очереди процессов с тем же приоритетом. Как следствие, он может очистить текущий запущенный процесс, если он имеет такой же приоритет. (POSIX 1003.1 рекомендует процессу перейти в конец списка). Процесс, вызывающий sched\_yield, также будет помещен в конец списка. Других способов перемещения процесса с алгоритмом *SCHED\_FIFO* в очереди процессов с одинаковыми статическими приоритетами не существует. Процесс с алгоритмом *SCHED\_FIFO* работает до тех пор, пока не будет заблокирован запросом на ввод/вывод, приостановлен процессом с большим статическим приоритетом или не вызовет sched\_yield.

1) <a name="_toc190183780"></a>SCHED\_RR: циклический алгоритм планирования

   Все, относящееся к алгоритму *SCHED\_FIFO*, справедливо и для *SCHED\_RR* за исключением того, что каждому процессу разрешено работать непрерывно не дольше некоторого времени, называемого квантом. Если процесс с алгоритмом *SCHED\_RR* работал столько же или дольше, чем квант, то он помещается в конец очереди процессов с тем же приоритетом. Процесс с алгоритмом *SCHED\_RR*, приостановленный процессом с большим приоритетом, возобновляя работу, использует остаток своего кванта. Длину этого кванта можно узнать, вызвав функцию sched\_rr\_get\_interval.

1) <a name="_toc190183781"></a>SCHED\_OTHER: стандартный алгоритм планировщика с разделением времени

   Алгоритм *SCHED\_OTHER* можно использовать только со значениями статического приоритета, равными нулю. *SCHED\_OTHER* – это стандартный алгоритм планирования Linux с разделением времени, предназначенный для процессов, не требующих специальных механизмов реального времени со статическими приоритетами. Порядок предоставления процессорного времени процессам со статическим приоритетом, равным нулю, основывается на динамических приоритетах, существующих только внутри этого списка. Динамический приоритет основан на уровне nice (установленном при помощи системных вызовов nice или setpriority) и увеличивается с каждым квантом времени, при котором процесс был готов к работе, но ему было отказано в этом планировщиком. Это приводит к тому, что, рано или поздно, всем процессам с приоритетом *SCHED\_OTHER* выделяется процессорное время.

   Получим возможные диапазоны приоритетов для каждого алгоритма планирования и узнаем текущий алгоритм и приоритет выполняемого процесса:

   priorities.c

   #include <stdio.h>

   #include <sched.h>

   int main (void) {

   `	`struct sched\_param shdprm; 	// Значения параметров планирования

   `	`printf ("диапазоны приоритетов для разных политик планирования\n");

   `	`printf ("SCHED\_FIFO : от %d до %d\n",

   `		`**sched\_get\_priority\_min** (SCHED\_FIFO),

   `		`**sched\_get\_priority\_max** (SCHED\_FIFO));

   `	`printf ("SCHED\_RR   : от %d до %d\n",

   `		`sched\_get\_priority\_min (SCHED\_RR),

   `		`sched\_get\_priority\_max (SCHED\_RR));

   `	`printf ("SCHED\_OTHER: от %d до %d\n",

   `		`sched\_get\_priority\_min (SCHED\_OTHER),

   `		`sched\_get\_priority\_max (SCHED\_OTHER));

   `	`printf ("Текущая политика планирования для текущего процесса: ");

   `	`switch (**sched\_getscheduler** (0)) {

   `		`case SCHED\_FIFO:

   `			`printf ("SCHED\_FIFO\n");

   `			`break;

   `		`case SCHED\_RR:

   `			`printf ("SCHED\_RR\n");

   `			`break;

   `		`case SCHED\_OTHER:

   `			`printf ("SCHED\_OTHER\n");

   `			`break;

   `		`case -1:

   `			`perror ("SCHED\_GETSCHEDULER");

   `			`break;

   `		`default:

   `			`printf ("Неизвестная политика планирования\n");

   `	`}

   `	`if (**sched\_getparam** (0, &shdprm) == 0) {

   `		`printf ("Текущий приоритет текущего процесса: %d\n",

   `					`shdprm.sched\_priority);

   `	`} else {

   `		`perror ("SCHED\_GETPARAM");

   `	`}

   `	`return 0;

   }

   Результат выполнения программы следующий:

   user@debian:~/OS/Lab3/2$ ./priorities

   диапазоны приоритетов для разных политик планирования

   SCHED\_FIFO : от 1 до 99

   SCHED\_RR   : от 1 до 99

   SCHED\_OTHER: от 0 до 0

   Текущая политика планирования для текущего процесса: SCHED\_OTHER

   Текущий приоритет текущего процесса: 0

   Попытаемся изменить приоритеты и текущую политику планирования. Пример кода программы:

   father.c

   #include <stdio.h>

   #include <sched.h>

   int main (void) {

   `	`struct sched\_param shdprm; 	// Значения параметров планирования

   `	`int pid, pid1, pid2, ppid;

   `    `pid = getpid();

   `    `ppid = getppid();

   `    `printf("FATHER PARAMS: pid=%i  ppid=%i\n", pid,ppid);

	

   `	`shdprm.sched\_priority = 50;

   `	`if (**sched\_setscheduler** (0, SCHED\_RR, &shdprm) == -1) {

   `		`perror ("SCHED\_SETSCHEDULER");

   `	`}

   `	`if((pid1=fork()) == 0)

   `		`execl("son1", "son1", NULL);

   `	`if((pid2=fork()) == 0)

   `		`execl("son2", "son2", NULL);

   `	`printf ("Текущая политика планирования для текущего процесса: ");

   `	`switch (**sched\_getscheduler** (0)) {

   `		`// код, аналогичный предыдущему примеру

   `	`}

   `	`if (**sched\_getparam** (0, &shdprm) == 0)

printf ("Текущий приоритет текущего процесса: %d\n",    shdprm.sched\_priority);

`	`else

`		`perror ("SCHED\_GETPARAM");

`	`return 0;

}

son1.c (son2.с аналогичен)

#include <stdio.h>

#include <stdlib.h>

#include <sched.h>

int main()

{

`	`struct sched\_param shdprm; 	// Значения параметров планирования	int i, pid,ppid;

`		`pid=getpid();

`		`ppid=getppid();

`		`printf("SON\_1 PARAMS:  pid=%i  ppid=%i\n",pid,ppid);

printf ("SON\_1: Текущая политика планирования для текущего процесса: ");

`		`switch (**sched\_getscheduler** (0))

`		`{

`		`// … код, аналогичный предыдущему примеру

`		`}

`		`if (**sched\_getparam** (0, &shdprm) == 0)

printf ("SON\_1: Текущий приоритет текущего процесса: %d\n", shdprm.sched\_priority);

`		`else

`			`perror ("SCHED\_GETPARAM");

`	`return 0;

}

При попытке исполнения программы от имени обычного пользователя, появляется сообщение об ошибке – о том, что операция изменения приоритета запрещена.

user@debian:~/OS/Lab3/2$ ./father

FATHER PARAMS: pid=14703  ppid=4701

SCHED\_SETSCHEDULER: Operation not permitted

Текущая политика планирования для текущего процесса: SCHED\_OTHER

Текущий приоритет текущего процесса: 0

SON\_1 PARAMS:  pid=14704  ppid=1

SON\_1: Текущая политика планирования для текущего процесса: SCHED\_OTHER

SON\_1: Текущий приоритет текущего процесса: 0

SON\_2 PARAMS:  pid=14705  ppid=1

SON\_2: Текущая политика планирования для текущего процесса: SCHED\_OTHER

SON\_2: Текущий приоритет текущего процесса: 0

Для корректного исполнения необходимы  права суперпользователя, тогда пример результатов работы программы:

root@debian:/home/user/OS/Lab3/2# ./father

FATHER PARAMS: pid=14769  ppid=14768

Текущая политика планирования для текущего процесса: SCHED\_RR

Текущий приоритет текущего процесса: 50

SON\_2 PARAMS:  pid=14771  ppid=1

SON\_1 PARAMS:  pid=14770  ppid=1

SON\_2: Текущая политика планирования для текущего процесса: SCHED\_RR

SON\_2: Текущий приоритет текущего процесса: 50

SON\_1: Текущая политика планирования для текущего процесса: SCHED\_RR

SON\_1: Текущий приоритет текущего процесса: 50

Таким образом, из результатов следует, что *потомки наследуют политику планирования* и *приоритет родительского процесса*.

Иначе структурируем программу для наблюдения за изменением приоритетов и политик. В программе, представленной ниже, выделены переменные для задания необходимых значений приоритетов и явным образом задается политика. 

#include <stdio.h>

#include <sched.h>

int main (void) {

`	`struct sched\_param shdprm; 	// значения параметров планирования

`	`int pid, pid1, pid2, pid3, ppid, status;

`	`int n, m, l, k;	// переменные для задания значений приоритетов, 

// для удобства можно оформить их как аргументы  командной 

// строки при запуске и 

// как аргумент добавить задаваемую политику планирования

`	`n=50; m=60; l=10; k=80;     // заданные значения приоритетов c политикой  RR

`       `// m=60; l=10; k=4;       //для повторного эксперимента с политикой FIFO

`    `pid = getpid();

`    `ppid = getppid();

`    `printf("FATHER PARAMS: pid=%i  ppid=%i\n", pid,ppid);



`	`shdprm.sched\_priority = n;

`	`if (sched\_setscheduler (0, SCHED\_RR, &shdprm) == -1) {

`		`perror ("SCHED\_SETSCHEDULER");

`	`}

`	`if((pid1=fork()) == 0)

`	`{

`		`shdprm.sched\_priority = m;

`		`if (sched\_setscheduler (pid1, SCHED\_RR, &shdprm) == -1)

`			`perror ("SCHED\_SETSCHEDULER\_1");

`		`execl("son1", "son1", NULL);

`	`}

`	`if((pid2=fork()) == 0)

`	`{

`		`shdprm.sched\_priority = l;

`		`if (sched\_setscheduler (pid2, SCHED\_RR, &shdprm) == -1)

`			`perror ("SCHED\_SETSCHEDULER\_2");

`		`execl("son2", "son2", NULL);

`	`}

`	`if((pid3=fork()) == 0)

`	`{

`		`shdprm.sched\_priority = k;

`		`if (sched\_setscheduler (pid3, SCHED\_RR, &shdprm) == -1)

`			`perror ("SCHED\_SETSCHEDULER\_3");

`		`execl("son3", "son3", NULL);

`	`}

`	`printf("Процесс с pid = %d завершен\n", wait(&status));

`	`printf("Процесс с pid = %d завершен\n", wait(&status));

`	`printf("Процесс с pid = %d завершен\n", wait(&status));

`	`return 0;

}

Для удобства исследования количество процессов, их приоритеты и политики планирования можно задавать как *настраиваемые исходные данные* либо из командной строки как параметры при запуске программы, либо как входной файл; можно включить файл с параметрами (param.h), содержащий структуру данных процесса со всеми необходимыми характеристиками и оперативно менять данные. Это даст возможность провести большое количество экспериментов с различными комбинациями данных на большом количестве процессов с целью дальнейшего анализа конкуренции процессов за ресурсы. 

Кроме того, для сбора статистики на множестве потомков достаточно многократное порождение потомка с одним и тем же именем и исходным кодом из одного исходного файла – ОС все равно различает новые процессы только по уникальным числовым идентификаторам. Символьная идентификация удобна для чтения результатов пользователем на заключительном этапе сбора выходных данных проверки работоспособности программ. Но учитывая, что для обеспечения достоверности информации о текущем планировании вывод целесообразнее формировать в ОЗУ, а уже затем выполнять символьную трансляцию с размещением в файл и/или на консоль, можно существенно сократить суммарный код родителя и потомка, а за счет параметризации сделать программу универсальной.

Следует учитывать, что даже при явно заданной политике и приоритетах нет гарантии, что вы увидите ожидаемую очередность предоставления процессорного ресурса процессам в соответствии с заявленными (заметьте, относительно простыми в случае систем общего назначения) алгоритмами, т.к. при исполнении реальных задач появляется много факторов, влияющих на поведение системы в целом, а планировщик лишь приспосабливается к предлагаемым условиям. 

К *факторам, влияющим на  результат планирования* можно отнести:

*характер выполняемых прикладных программ* – как часто они уходят в режим ожидания при запросе других ресурсов (например, при работе с внешними устройствами. Или, например, часто используемые printf(), sleep(), system() и т.п. приводят к передаче управления другим процессам, нарушая очередность исполнения. Поэтому, если вы используете их для иллюстративности при исследовании характеристик планирования, лучше применять другие подходы). Одним из таких подходов является накопление текущей информации в оперативной памяти, а по окончании сбора статистики перед завершением программы трансляция выходной информации в удобный вид и вывод в файл или на терминал. Другой подход – использование системного журналирования событий. Например, функция логирования **syslog()** и сопутствующие ей функции **openlog();** **closelog();** позволяют задавать интересующие характеристики или события, с появлением которых накапливать их системными средствами и записывать сформулированные в программе сообщения, соответствующие этим событиям, в выходной файл. В Linux Debian, например, результаты вывода можно найти в **/var/log/messages**. Существуют и другие средства журналирования и трассировки;

*наличие аппаратных возможностей распараллеливания вычислений,* например, *многоядерности или многопроцессорности*. В этом ислучае для прогнозирования предоставления процессорного ресурса неоходимо знание алгоритмов распределения нагрузки между вычислителями (при отсутствии других факторов, влияющих на перераспределение), их взаимодействия с памятью и более тщательный анализ ситуации (при наличии других факторов влияния);

*обмен и размещение процессов в памяти*. В Unix ОС используется страничное распределение памяти. Как правило, сначала начинает выполняться процесс, который уже находится в ОП. Поэтому если при порождении потомков первому соднанному из них вы присвоете низкий приоритет, то велика вероятность, что независимо от наличия более высокоприоритетных, готовых к исполнению, именно он все время (при многократных запусках) будет выполняться первым, т.к. он уже в памяти. Чтобы уменьшить влияние этого фактора, можно воспользоваться, например, функцией запрета страничного обмена;

*и другие*.

Функция mlockall() запрещает страничный обмен для всех страниц в области памяти вызывающего процесса. Это касается всех страниц сегментов кода, данных и стека, разделяемых библиотек, пользовательских данных ядра, разделяемой памяти и отображенных в память файлов. Все эти страницы будут помещены в ОЗУ, если вызов **mlockall()** был выполнен успешно, и останутся там до тех пор, пока не будут освобождены вызовами **munlock()** или **munlockall(),** или если процесс завершит работу или запустит другую программу при помощи exec(). Блокировка страниц не наследуется потомками, созданными при помощи fork(). Примеры использования перечисленных функций есть в кодах программ, представленных далее. Блокировки памяти используют, в основном, в алгоритмах реального времени и при работе с защищенными данными.

# <a name="_toc190185314"></a>**Характеристики квантования**

Попробуем определить величину кванта, и выяснить, можно ли ее изменять. Понятно, что изменение этой величины может существенно влиять на характеристики функционирования ОС в целом, а главное, на эффективность исполнения приложений: при частых переключениях происходит уменьшение производительности (например, при времени переключения 1 мс квант – 4 мс),  а при редких –увеличение  времени ответа на запрос (например, при том же времени переключения квант – 100 мс). Таким образом, существенным является соотношение величины кванта и времени самого переключения.

Определить величину кванта можно с помощью функции  (POSIX)

`	`int    **sched\_rr\_get\_interval**(pid\_t, struct timespec \*);

приведем пример ее использования для политики планирования RR.

father.c

#include <stdio.h>

#include <sched.h>

#include <sys/mman.h>

int main (void) {

`	`struct sched\_param shdprm; 	// Значения параметров планирования

`	`struct timespec qp; 		// Величина кванта	

`	`int i, pid, pid1, pid2, pid3, ppid, status;

`    `pid = getpid();

`    `ppid = getppid();

`    `printf("FATHER PARAMS: pid=%i  ppid=%i\n", pid,ppid);

`	`shdprm.sched\_priority = 50;

`	`if (**sched\_setscheduler** (0, SCHED\_RR, &shdprm) == -1)

`			`perror ("SCHED\_SETSCHEDULER\_1");

`	`if (**sched\_rr\_get\_interval** (0, &qp) == 0)

`	`printf ("Квант при циклическом планировании: %g сек\n",

`					`qp.tv\_sec + qp.tv\_nsec / 1000000000.0);

`	`else

`		`perror ("SCHED\_RR\_GET\_INTERVAL");

`	`if((pid1=fork()) == 0)

`	`{	

`		`if (sched\_rr\_get\_interval (pid1, &qp) == 0)

`			`printf ("SON: Квант процессорного времени: %g сек\n",

`						`qp.tv\_sec + qp.tv\_nsec / 1000000000.0);

`		`execl("son", "son", NULL);

`	`}

`		`printf("Процесс с pid = %d завершен\n", wait(&status));

`	`return 0;

}

son.c

#include <stdio.h>

int main()

{

`	`printf("SON PARAMS:  pid=%i  ppid=%i\n", getpid(), getppid()); 	

`	`return 0;

}

Пример результата выполнения:

FATHER PARAMS: pid=16977  ppid=16760

Квант при циклическом планировании:** 0.100006 сек

SON: Квант процессорного времени: 0.100006 сек

SON PARAMS:  pid=16978  ppid=16977

Процесс с pid = 16978 завершен

В рамках одной политики планирования для большинства ОС Linux на значение кванта не влияет ни количество процессов, ни их нагруженность, ни их иные характеристики, для всех процессов величина кванта одинакова и постоянна.

Однако, если проверить величину кванта при алгоритме планирования FIFO, то он ожидаемо будет составлять 0 сек, а при алгоритме OTHER — почти на порядок меньше (для Linux Debian – 0.016001 сек, напомним, что при RR для той же системы она составляла 0.100006 сек).

`   `Современные ОС linux не имеют специального механизма, который позволял бы устанавливать величину кванта процессорного времени для RR—планировщика из приложений в отличие от более старых версий, где квантом можно было управлять, регулируя параметр процесса nice. Отрицательное значение nice — квант длиннее, положительное — короче. <a name="result_box"></a>Степень влияния значения nice на квант в разных версиях ядра была различной. Начиная с версии  Linux 2.6.24, квант SCHED\_RR не может быть изменен документированными средствами. Экспериментально это можно проверить, используя системную функцию nice():

`	`if ((nice = nice(1000)) == -1)

`		`perror("NICE");

`	`else

`		`printf ("Nice value = %d\n", nice);

В других ОС, *поддерживающих POSIX*, величину кванта можно менять, в том числе из системных приложений, оптимизируя функционирование прикладных задач. Особенно это существенно для ОС реального времени и систем технического управления. 

# <a name="_toc190185315"></a>**Функции изменения приоритетов**

Кроме уже представленных ранее возможностей изменения приоритетов средствами функций управления политикой планирования, существуют специально предназначенные для этого функции и утилиты. Одна из них 

nice(1) — утилита, запускающая программу с измененным приоритетом. Если не указано ни одного аргументы, команда выводит текущий унаследованный приоритет. В противном случае, nice запускает команду с указанным приоритетом. Если смещение не указано, то приоритет команды увеличивается на 10. команда nice может смещать приоритет в диапазоне от -20 до 19 включительно, когда используются права суперпользователя. Когда команда выполняется обычным пользователем, диапазон изменяется от 0 до 19.

Рассмотрим пример.

При запуске нескольких утилит, они, как правило, начинают выполняться с конца:

user@debian:~/OS/Lab3/10$ echo 1 & echo 2

2

1

user@debian:~/OS/Lab3/10$ nice -n 1 echo 1 & nice -n 10 echo 2

1

2

Использование nice возможно как с правами root, так и обычного пользователя.

Кроме упоминаемой ранее функции nice(), часто используются функции:

#include <sys/time.h>

#include <sys/resource.h>

int **getpriority**(int which, int who);

int **setpriority**(int which, int who, int prio);

Функциями getpriority() и setpriority() можно получить и установить приоритет для процесса, группы, и пользователя, в зависимости от заданных значений which и who:

Which: PRIO\_PROCESS, PRIO\_USER, PRIO\_PGRP,

Who: идентификатор PID,

Prio: приоритет.

Определим границы приоритетов, используя программу lim.c:

#include <stdio.h>

#include <sys/time.h>

#include <sys/resource.h>

void main()

{

`    `int pr, pid, i;

`    `pid=getpid();



`	`for (i = -100; i < 1; i++)

`	`{

`		`setpriority(PRIO\_PROCESS, pid, i);

`		`pr = getpriority(PRIO\_PROCESS, pid);

`		`if (pr != i) continue;

`		`else

`		`{

`			`printf("Нижняя граница = %d\n", pr);

`			`printf("Запросили %d, получили %d\n", i, pr);

`			`break;

`		`}

`	`}

`	`for (i = 1; i < 100; i++)

`	`{

`		`setpriority(PRIO\_PROCESS, pid, i);

`		`pr = getpriority(PRIO\_PROCESS, pid);

`		`if (pr == i) continue;

`		`else

`		`{

`			`printf("Верхняя граница = %d\n", pr);

`			`printf("Запросили %d, получили %d\n", i, pr);

`			`break;

`		`}

`	`}

}

Результат выполнения отличается для привилегированного и обычного пользователей:

user@debian:~/OS/Lab3/10$ ./lim

Нижняя граница = 0

Запросили 0, получили 0

Верхняя граница = 19

Запросили 20, получили 19

root@debian:/home/user/OS/Lab3/10# ./lim

Нижняя граница = -20

Запросили -20, получили -20

Верхняя граница = 19

Запросили 20, получили 19

*Приоритеты системного класса устанавливаются ядром*. 

Класс реального времени использует стратегию планирования с фиксированными приоритетами, таким образом, для особо важных или критичных процессовможно организовать предварительное расписание (порядок исполнения). *Приоритеты реального времени* – **статические** и меняются лишь по предварительному требованию. 

Только *привилегированный пользователь может устанавливать приоритеты реального времени*, используя priocntl(2).

# <a name="_toc190185316"></a>**Управление заданиями. Утилиты jobs и fg**

Запустим в фоновом режиме несколько утилит:

$ sleep 100 & sleep 110 & sleep 120 & sleep 130 &

[1] 7154

[2] 7155

[3] 7156

[4] 7157

C помощью утилиты jobs -l можно проанализировать порядок выполнения поставленных задач:

user@debian:~/OS/Lab3/10$ jobs -l

[1]   7154 Running                 sleep 100 &

[2]   7155 Running                 sleep 110 &

[3]-  7156 Running                 sleep 120 &

[4]+  7157 Running                 sleep 130 &

user@debian:~/OS/Lab3/10$ jobs -l %%

[4]+  7157 Running                 sleep 130 &

Из результатов следует, выполнение команд начинается с конца.

Отменим одну из задач:

$ kill 7156

[3]-  Завершено      sleep 120

$ jobs -l

[1]   7154 Running                 sleep 100 &

[2]-  7155 Running                 sleep 110 &

[4]+  7157 Running                 sleep 130 &

С помощью утилиты **fg** можно повысить приоритет задач. Например,

user@debian:~/OS/Lab3/10$ fg %1

sleep 100

Благодаря ей, сразу начинает выполняться задача 1, причем не в фоновом режиме.

Новые добавленные задачи добавляются в конец очереди и начинают выполняться первыми.

user@debian:~/OS/Lab3/10$ sleep 30 &

[5] 7183

[2]   Done                    sleep 110

user@debian:~/OS/Lab3/10$ jobs -l

[4]-  7157 Running                 sleep 130 &

[5]+  7183 Running                 sleep 30 &

# <a name="_toc190185317"></a>**Наследование при создании процессов**

Проанализируем наследование на этапах fork() и exec(). Для этого проведем эксперимент по проверке доступа потомков к файлам, открытым породившим их процессом. Рассмотрим пример кода, в котором в качестве аргументов процессам-потомкам передаются дескрипторы открытого и созданного родительским процессом файлов (в данном примере это infile.txt и outfile.txt соответственно). Порожденные процессы независимо друг от друга вызывают функции read и write, и в цикле считывают по одному байту информацию из исходного файла и переписывают ее в файл вывода. 

father.c

#include <stdio.h>

#include <sched.h>

#include <sys/mman.h>

#include <stdlib.h>

#include <unistd.h>

#include <fcntl.h>

void itoa(char \*buf, int value) {

`    `sprintf(buf, "%d", value);

}

int main (void)

{ 

`	`int i, pid, ppid, status;

`	`int fdrd, fdwr;

`	`char str1[10], str2[10];

`	`char c;

`	`struct sched\_param shdprm;



` `if (mlockall((MCL\_CURRENT | MCL\_FUTURE)) < 0)

`		`perror("mlockall error");	

pid = getpid();

`   	`ppid = getppid();



shdprm.sched\_priority = 1;

`	`if (sched\_setscheduler (0, SCHED\_RR, &shdprm) == -1)

`			`perror ("SCHED\_SETSCHEDULER\_1");



if ((fdrd = open("infile.txt",O\_RDONLY)) == -1)

`		`perror("Openning file");

`	`if ((fdwr = creat("outfile.txt",0666)) == -1)                

`		`perror("Creating file");

`	`itoa(str1, fdrd);

`	`itoa(str2, fdwr);



for (i = 0; i < 2; i++)

`		`if(fork() == 0)	

`		`{

`			`shdprm.sched\_priority = 50;

`			`if (sched\_setscheduler (0, SCHED\_RR, &shdprm) == -1)

`				`perror ("SCHED\_SETSCHEDULER\_1");

`			`execl("son", "son", str1, str2, NULL);

`		`}



if (close(fdrd) != 0)

`		`perror("Closing file");

`	`for (i = 0; i < 2; i++)

`		`printf("Процесс с pid = %d завершен\n", wait(&status));

`	`return 0;

}

son.c

#include <sched.h>

#include <sys/mman.h>

#include <fcntl.h>

int main(int argc, char \*argv[])

{		

`	`if (mlockall((MCL\_CURRENT | MCL\_FUTURE)) < 0)

`		`perror("mlockall error");	

`	`char c;	

`	`int pid, ppid, buf;

`	`int fdrd = atoi(argv[1]);

`	`int fdwr = atoi(argv[2]);



pid=getpid();

`	`ppid=getppid();

`	`printf("son file decriptor = %d\n", fdrd);

`	`printf("son params:  pid=%i  ppid=%i\n",pid,ppid);

`	`sleep(5);



`	`for(;;)                                                

`    `{                                                      

`	    `if (read(fdrd,&c,1) != 1)                     

`			`return 0;                                     

`       	    `write(fdwr,&c,1);

`	    `printf("pid = %d: %c\n", pid, c);                                

`    `}

`	`return 0;

}

Дескрипторы fdrd *в обоих потомках* указывают на запись в таблице файлов, соответствующую исходному файлу, а дескрипторы, подставляемые в качестве fdwr, на запись, соответствующую файлу вывода. Ядро смещает внутрифайловые указатели после каждой операции чтения или записи, поэтому оба процесса никогда не обратятся вместе на чтение или запись по одному и тому же указателю или смещению внутри файла. 

Содержимое выходного файла зависит от очередности, в которой ядро ставит процессы на выполнение. Если очередность такая, что процессы исполняют системные функции попеременно (чередуя пары вызовов функций read-write), содержимое выходного файла будет совпадать с содержимым входного файла. В примере рассматривается случай, когда используется RR-политика с равными приоритетами процессов, потомки пользуются одной переменной для считанного из входного файла символа, т.к. в результате наследования разделяют одно адресное пространство, и результат выполнения программы получается следующим:


./father

son file decriptor = 3

son params: pid=21331  ppid=21319

son file decriptor = 3

son params: pid=21330  ppid=21319

pid = 21331: H

pid = 21330: e

pid = 21331: l

pid = 21330: L

pid = 21331: o

pid = 21330: 

pid = 21331: w

pid = 21330: o

pid = 21331: r

pid = 21330: l

pid = 21331: d

pid = 21330: ! 

pid = 21331: 

pid = 21330: 

Процесс с pid = 21340 завершен

Процесс с pid = 21341 завершен

Содержимое infile.txt:		HelLo world!

Содержимое outfile.txt:		eL ol!                     

В итоге в такой реализации в выходной файл записался каждый второй символ. В данном случае последовательность вывода можно изменить либо изменив код программы, либо меняя параметры планирования. Первый способ естественно проще. В реальных приложениях смена параметров планирования должна быть глубоко *обоснована,* и предварительно проанализированы все ее последствия, в том числе и для других приложений, работающих в системе.

`	`При выполнении функции fork() ядро создает потомка как копию родительского процесса, процесс-**потомок** **наследует** от родителя:

`    `сегменты кода, данных и стека программы;

`    `таблицу файлов, в которой находятся состояния флагов дескрипторов файла, указывающие допустимые операции над файлом. Кроме того, в таблице файлов содержится текущая позиция указателя записи-чтения;

`    `рабочий и корневой каталоги;

`    `реальный и эффективный идентификатор пользователя и номер группы;

`    `приоритеты процесса (администратор может изменить их через nice);

`    `терминал;

`    `маску сигналов;

`    `ограничения по ресурсам;

`    `сведения о среде выполнения;

`    `разделяемые сегменты памяти.

**Потомок не наследует** от родителя:

`    `идентификатора процесса (PID, PPID);

`    `израсходованного времени ЦП (оно обнуляется);

`    `сигналов процесса-родителя, требующих ответа;

`    `блокированных файлов (record locking).

Продолжая эксперимент с  программой демонстрирующей наследование файловых дескрипторов открытых файлов и указателей на позицию при чтении и записи в файл, попробуем закрыть в одном из процессов файл с заданным дескриптором, например, fdrd в son.c:

for(;;)                                                

`    `{                                                      

`	    `if (read(fdrd,&c,1) != 1)                     

`			`return;                                     

`        `write(fdwr,&c,1);

`		`printf("pid = %d: %c\n", pid, c);

`		`if (close(fdrd) != 0)

`			`perror("Closing file");                                

`    `}

Результатом выполнения будет частичное чтение исходного файла до его закрытия одним из потомков, например:

root@debian:/home/user/OS/Lab3/8# ./father

son file decriptor = 3

son params:  pid=21530  ppid=21528

son file decriptor = 3

son params:  pid=21529  ppid=21528

pid = 21530: H

pid = 21529: e

Процесс с pid = 21530 завершен

Процесс с pid = 21529 завершен

Содержимое infile.txt:		HelLo world!

Содержимое outfile.txt:		e

Убедиться в наследовании других параметров при порождении потомков можно, проанализировав вывод утилиты

`	`ps -o uid,gid,ruid,pid,ppid,pgid,tty,vsz,stat,command 

`  `UID   GID  RUID   PID       PPID      PGID    TT       VSZ STAT COMMAND

`    `0        0      1000    21766   18816    21766    pts/3     1708 SL+  ./father

`    `0        0      1000    21767   21766    21766    pts/3     1712 SL+  son 3 4

`    `0        0      1000    21768   21766    21766    pts/3     1712 SL+  son 3 4

`    `0        0      1000    21769   21766    21766    pts/3      940   S+   sh -c  ps -o …

`    `0        0      1000    21770   21769    21766    pts/3     4136 R+   ps -o 

`					`uid,gid,ruid,pid,ppid,pgid,tty,vsz,stat,command

т.е. от родителя наследуются UID, GID, RUID, PGID,TTY и, как было показано ранее, приоритеты и политика планирования процессов. Что касается наследования сигналов, рассмотрим это далее при обсуждении сигналов, как средства IPC.

# <a name="_toc190185318"></a>**Взаимодействие родственных процессов**

Родственными считаются процессы, ближайшие в дереве процессов, т.е. породивший и порожденные им процессы. Их взаимодействие основывается на наследовании, подробно рассмотренном ранее. Оно существенно проще по сравнению с взаимодействием независимых процессов, поскольку независимые процессы полностью изолированы друг от друга и нуждаются в посреднике при обмене информацией в виде ядра ОС. Ядро предоставляет им специальные механизмы доступа и синхронизации (IPC) и управляет адресным пространством. Возможности совместного использования адресного пространства и других наследуемых ресурсов позволяют «дёшево» расширять функциональность приложений без усложнения кода использованием IPC. Но для разработки таких приложений необходимо понимать правила и особенности совместного выполнения родственных процессов.

Поставим простой эксперимент: процесс-родитель создает трех потомков, выполняющихся с различной длительностью по отношению к породившему их процессу: 

а) процесс-отец запускает процесс-сын, ожидает и дожидается его завершения (независимо от длительности выполнения потомка);

б) процесс-отец запускает процесс-сын и, не ожидая его завершения, завершается сам; 

в) процесс-отец запускает процесс-сын и не ожидает его завершения; а процесс-сын завершает свое выполнение до завершения родителя. 

Для упрощения анализа результатов изменения таблицы процессов будем использовать системную функцию system(), а в качестве ее аргументов формировать командную строку с вызовом утилиты статуса с нужными ключами и фильтрацией вывода, а также перенаправлением этого вывода не только на терминал, но и в файл. 

Для рассмотрения перечисленных ситуаций используем следующий код:

father.c   (создает 3 потомка)

#include <stdio.h>

#include <unistd.h>

#include <sys/types.h>

#include <wait.h>

#include <string.h>

int main(int argc, char \*argv[])

{

`   	`int sid, pid, pid1, ppid, status;

`	`char command[50];

`	`if (argc < 2)

`		`return -1;

`	`pid = getpid();

`  	`ppid = getppid();

`	`sid = getsid(pid);

`	`sprintf(command, "ps xjf | grep \"STAT\\|%d\" > %s", sid, argv[1]);

`  `printf("FATHER PARAMS: sid = %i  pid=%i  ppid=%i \n", sid, pid,ppid);

`  	`if((pid1=fork())==0) execl("son1","son1", NULL);

`	`if(fork()==0) execl("son2","son2", argv[1], NULL);

`	`if(fork()==0) execl("son3","son3", NULL);

`	`system(command);

`  `waitpid(pid1, &status, WNOHANG); //эта строка исключается в п.б) и в)

}

`	`a) son1 

#include <stdio.h>

void main()

{

`	`int pid,ppid;

`	`pid=getpid();

`	`ppid=getppid();

printf("SON\_1 PARAMS:  pid=%i  ppid=%i\nFather creates and waits \n", pid, ppid);

`	`sleep(3);

}

`	`б) son2 (father завершает свое выполнение раньше son2)

#include <stdio.h>

void main(int argc, char \*argv[])

{

`	`int pid,ppid;

`	`pid=getpid();

`	`ppid=getppid();

`	`char command[50];

`	`sprintf(command, "ps xjf | grep son2 >> %s", argv[1]);

`	`printf("SON\_2 PARAMS:  pid=%i  ppid=%i\nFather finished 

before son  termination without waiting for it \n",pid,ppid);

`	`sleep(20);

`	`ppid=getppid();

`	`printf("SON\_2 PARAMS ARE CHANGED:  pid=%i  ppid=%i\n",pid,ppid);

`	`system(command);

}

`	`в) son3  (father не ожидает его завершения; son3 завершается)

#include <stdio.h>

void main()

{

`	`int pid,ppid;

`	`pid=getpid();

`	`ppid=getppid();

printf("SON\_3 PARAMS:  pid=%i  ppid=%i\nson3 terminated – 

`									`ZOMBIE\n",pid,ppid);

`	`ppid=getppid();

`	`printf("SON\_3 PARAMS:  pid=%i  ppid=%i\n",pid,ppid);

}

Согласно коду результаты выполнения всех трех ситуаций отображаются на консоли, а в итоговый файл, который передается в качестве параметра father.c, записываются результаты выполнения (ps\_ xjf) во время выполнения программ.

user@debian:~/ OS/Lab3/3 $ ./father res.txt

FATHER PARAMS: sid = 14095  pid=25941  ppid=14095

SON\_1 PARAMS:  pid=25942  ppid=25941

Father creates and waits 

SON\_2 PARAMS:  pid=25943  ppid=25941

Father finished before son termination without waiting for it 

SON\_3 PARAMS:  pid=25944  ppid=25941

son3 terminated - ZOMBIE 

SON\_3 PARAMS:  pid=25944  ppid=25941

user@debian:~/OS/Lab3/3 $ SON\_2 PARAMS ARE CHANGED:  pid=25943  ppid=1

В коде son2 для увеличения длительности существования потомка используется задержка в 20 сек,  в результате более раннего завершения родителя потомок становится наследником init, PID которого равен единице, т.е. son2 становится «самостоятельным» процессом с PPID=1, что и фиксируется в выходных данных в результате исполнения.

Как видно из результатов, как только процесс-отец завершается, на консоли сразу появляется приглашение на ввод команды. А son2 продолжает свое выполнение в фоновом режиме. Т.к. Время выполнения son2 много дольше, то результат выполнения процесса-потомка, пофвялется уже после приглашения.

Содержимое файла вывода res.txt:

PPID	PID  	PGID   SID     TPGID  STAT  COMMAND

` `4694 	14095 	14095 	14095  25941       Ss      |   |   \\_ bash

14095 	25941 	25941 	14095  25941       S+     |   |       \\_ ./father res.txt

**25941  25942 25941 	14095  25941       S+     |   |           \\_ son1**

25941	25943 25941 	14095  25941       S+     |   |           \\_ son2 res.txt

**25941 	25944 	25941 	14095  25941       Z+     |   |           \\_ [son3] <defunct>**

25941 	25945 	25941 	14095  25941       S+     |   |           \\_ sh -c ps xjf | grep "STAT\|14095" > res.txt

25945	 25946 25941 	14095  25941       R+     |   |              \\_ ps xjf

25945 	25947 	25941 	14095  25941       S+     |   |              \\_ grep STAT\|14095

`    `**1 	25943	25941 	14095  14095       S       son2 res.txt**

25943 	25950 	25941 	14095  14095       S       \\_ sh -c ps xjf | grep son2 >> res.txt

25950 	25952 	25941 	14095  14095       S            \\_ grep son2

В файле отображаются выполняемые процессы, условное дерево порождения процессов, их атрибуты и состояния.  (В выводе ввиду однородности представленной в них информации изъяты поля TTY (для всех процессов один и тот же ассоциированный терминал – pts/1), TIME, UID – для всех процессов одинаков и равен 1000). 

В выводе зафиксированы:  нормальное выполнение потомка son1; смена родителя son2 (PPID =1) и его переход в самостоятельную ветку; а также состояние zombie для son3 (ситуация, когда потомок выполняется быстрее процесса-отца, при этом отец не дожидается и никак не фиксирует завершение потомка).

*Состояние zombie* означает, что процесс остается формально существующим, но ресурсы, отведенные для него, освобождаются. Поясним это подробнее.

В UNIX системах в дереве порождения предусмотрены не только ниспадающие связи от родителей к потомкам (за счет наследования), но и обратные: родитель «несет ответственность» за потомка, получает статус его завершения. Поэтому в случае нестандартных ситуаций: при более раннем чем потомок завершении родителя назначается новый следящий (опекун) теперь уже гарантированно существующий до конца сессии, а при «отказавшемся родителе» (отсутствии функции семейства wait) и завершении потомка – предусмотрено специальное состояние (zombie), при котором потомок уже не занимает ресурсы, следовательно, не может выполняться, а информация о нем еще сохраняется на случай, если кто-то, в частности, родитель запросит статистику использования ресурсов этим потомком или его статус завершения. Для уведомления о завершении потомка служит специально выделенный сигнал SIGCHLD (см. в разделе, посвященном IPC).

# <a name="_toc190185319"></a>**Многонитевое функционирование**

Потоки (или нити) стандартизованы в Unix-подобных системах с 2004г., в различных ОС этого семейства допускают различную интерпретацию этого термина, но во всех случаях потоки рассматриваются обязательно как часть процесса, в который они входят, и разделяют ресурсы этого процесса наравне с другими потоками этого процесса (адресное пространство, файловые дескрипторы, обработчики сигналов и т.д.). При создании новых потоков в рамках существующего процесса им  нет необходимости создавать собственную копию адресного пространства (и других ресурсов) своего родителя, поэтому требуется значительно меньше затрат, чем при создании нового дочернего процесса. В связи с этим в Linux для обозначения потоков иногда используют термин – *легкие процессы* (англ. *lightweight processes*). 

Потоки одного процесса имеют общий PID, именно этот идентификатор используется при «общении» с многопоточным приложением. Функция getpid(2), возвращает значение идентификатора процесса, фактически группы входящих в него потоков, независимо от того, из какого потока она вызвана. Функции kill() waitpid() и им подобные по умолчанию также используют *идентификаторы групп потоков* (англ. *thread groups*), а не отдельных потоков. Как правило, идентификатор группы равен идентификатору первого потока, входящего в многопоточное приложение. Получить *идентификатор потока* (thread ID) можно с помощью функции gettid(2), которую нужно определить с помощью макроса \_syscall : 

int tid, pid;

tid = syscall(SYS\_gettid); 

Приведем пример распределения идентификаторов в результате выполнения программы в Linux, порождающей 10 потоков повышая приоритет посредством nice() каждому новому потоку:

… :~/os/lab3$ sudo ./pool

Thread 1 started

Thread 2 started

Thread 3 started

Thread 10 started

Thread 9 started

Thread 6 started

Thread 8 started

Thread 7 started

Thread 4 started

Thread 5 started

F S   UID   PID  PPID   LWP  C PRI  NI ADDR SZ WCHAN  CMD

4 S     0      2358  2143  2358  0  80     0 -  2018 poll\_s sudo

4 S     0      2359  2358  2359  0  80     0 - 21059 wait   pool

1 R     0      2359  2358  2360 86  81   1 - 21059 -      pool

1 R     0      2359  2358  2361 69  82   2 - 21059 -      pool

1 R     0      2359  2358  2362 58  83   3 - 21059 -      pool

1 R     0      2359  2358  2363 40  84   4 - 21059 -      pool

1 R     0      2359  2358  2364 42  85   5 - 21059 -      pool

1 R     0      2359  2358  2365 34  86   6 - 21059 -      pool

1 R     0      2359  2358  2366 25  87   7 - 21059 -      pool

1 R     0      2359  2358  2367 19  88   8 - 21059 -      pool

1 R     0      2359  2358  2368 16  89   9 - 21059 -      pool

1 R     0      2359  2358  2369 12  90   10 - 21059 -    pool

0 S     0      2370  2359  2370  0  80     0 -  567 wait   sh

0 R     0      2371  2370  2371  0  80     0 -  1554 -      ps

Thread1 ttid 2360,   4170.650 ms

Thread2 ttid 2361,   4775.534 ms

Thread3 ttid 2362,   5436.344 ms

Thread4 ttid 2363,    6088.717 ms

Thread 5  ttid 2364,  6867.238 ms

Thread6  ttid 2365,     7244.171 ms

Thread 7  ttid 2366,    7976.146 ms

Thread 8  ttid 2367,    8757.861 ms

Thread 9  ttid 2368,    8856.111 ms

Thread 10 ttid 2369,   9024.041 ms


Очевидно, что потокам присваиваются идентификаторы (tid, начиная с 2360), следующие по значению после PID процесса (2359) запускаемого приложения pool. (В последнем столбце выведен результат подсчета времени работы каждого потока. Чем больше nice, тем медленнее работает поток, то есть тем ниже приоритет.)

`	`Для создания и запуска нитей используются функции (для нити n): 


#include <pthread.>h

`    `void\* threadn (void\* ); 

`    `pthread\_t  tn;

pthread\_create (&tn, NULL, threadn, NULL); 
pthread\_join (tn, NULL); 

Пример структуры кода с порождением потоков (нитей):

**Thread.c**

#include <signal.h>

#include <pthread.h>

#include <stdio.h>

pthread\_t  t1, tn;

void\* thread1()

{

`    `printf("Thread\_1 is started\n");

`		`// здесь код, который должна выполнять нить 

`    		`//   system("ps axhf > thread1.txt");

}

void\* threadn()

{

`        `printf("Thread\_n is started\n");

`    `// здесь код, который должна выполнять нить n 

`	`//system("ps axhf > threadn.txt");

}

void main()

{	

`    `system("ps axhf > file.txt");

`    `pthread\_create(&t1, NULL, thread1, NULL);

…

`    `pthread\_create(&tn, NULL, thread2, NULL);

`	`system("ps axhf >> file.txt");

`    `pthread\_join(t1, NULL);

…

`    `pthread\_join(tn, NULL);

`	`system("ps axhf >> file.txt");

}

При попытке завершить поток обычным способом с помощью команды kill, *завершится **все** многопоточное приложение*. Результат будет одинаков при использовании в качестве аргумента функции как PID процесса, так и TID потоков.

*Функции для задания приоритетов нитям и политики планирования*:

pthread\_attr\_init - инициализация описателя атрибутов потока управления;

pthread\_attr\_setinheritsched – установка атрибута "наследование стратегии и параметров планирования" потока управления, например, атрибут PTHREAD\_EXPLICIT\_SCHED, при котором стратегия планирования и связанные с ней атрибуты должны быть взяты из описателя атрибутов, на который указывает аргумент attr, а не наследоваться от процесса-отца;

\_attr\_setschedparam – установка атрибута "параметры планирования" потока управления, с помощью которых был задан приоритет;

pthread\_attr\_setschedpolicy – установка атрибута "стратегия планирования" потока управления;

pthread\_attr\_getschedparam — получение текущего атрибута "параметры планирования" потока управления;

pthread\_attr\_getschedpolicy – получение текущего  атрибута "политика планирования" потока управления;

pthread\_attr\_destroy – удаление описателя атрибутов потока управления.

Приоритет и политику планирования для потоков можно задать и другим способом - наследуя от процесса-родителя с помощью функции 

` `pthread\_attr\_setinheritsched (&attr, PTHREAD\_INHERIT\_SCHED) 

с атрибутом наследования.

`	`Для исследования и анализа характеристик планирования потоков можно использовать следующий примерный программный код:

#include <signal.h>

#include <pthread.h>

#include <stdio.h>

#include <sys/types.h>

#include <linux/unistd.h>

#include <sys/syscall.h>

#include <sched.h>

pthread\_t  t1, t2;

void\* thread1()

{

`    `int i, count = 0;

`	`int tid, pid;

`	`tid = syscall(SYS\_gettid);

`	`pid = getpid();

`    `printf("Thread\_1 with thread id = %d and pid = %d is started\n", tid, pid);

`	`// здесь размещаем собственно функциональный код нити

`	`// для примера приведен простой бессмысленный код

`	`for (i = 0; i < 10; i++)

`    `{

`		`printf("Thread\_1: %d\n", i);

`    `}



}

void\* thread2()

{

`    `int i, count = 0;

`	`int tid, pid;

`	`tid = syscall(SYS\_gettid);

`	`pid = getpid();

`    `printf("Thread\_2 with thread id = %d and pid = %d is started\n", tid, pid);

// здесь размещаем собственно функциональный код нити

`	`// для примера приведен простой бессмысленный код

`	`for (i = 0; i < 10; i++)

`   	 `{

`		`printf("Thread\_2: %d\n", i);

`   	 `}

}

void main()

{	

`	`int policy;

`	`struct sched\_param param;	

`	`pthread\_attr\_t attr\_1, attr\_2;                                        

`   	`pthread\_attr\_init(&attr\_1);                                                      

`   	`pthread\_attr\_init(&attr\_2);	

`	`pthread\_attr\_setschedpolicy(&attr\_1, SCHED\_RR);

`	`pthread\_attr\_setschedpolicy(&attr\_2, SCHED\_RR);

`    `//значения приоритетов лучше задавать извне – из командной строки или файла

`    `param.sched\_priority = 10; 

`	`pthread\_attr\_setschedparam(&attr\_1, &param);

`    `param.sched\_priority = 30;

`	`pthread\_attr\_setschedparam(&attr\_2, &param);

// Стратегия планирования и связанные с ней атрибуты должны быть взяты из описателя   //атрибутов, на который указывает аргумент attr 

pthread\_attr\_setinheritsched (&attr\_1, PTHREAD\_EXPLICIT\_SCHED);	pthread\_attr\_setinheritsched (&attr\_2, PTHREAD\_EXPLICIT\_SCHED); 

// Стратегия планирования и связанные с ней атрибуты должны быть унаследованы 

// Установка атрибута наследования от родителя

//pthread\_attr\_setinheritsched (&attr\_1, PTHREAD\_INHERIT\_SCHED)

// Установка статуса освобождения ресурсов

`	`//pthread\_attr\_setdetachstate (&attr,PTHREAD\_CREATE\_DETACHED);	

`	`pthread\_attr\_getschedparam(&attr\_1, &param);

`	`pthread\_attr\_getschedpolicy(&attr\_1, &policy);

`	`printf("Thread\_1's priority = %d\n", param.sched\_priority);

`	`pthread\_attr\_getschedparam(&attr\_2, &param);

`	`pthread\_attr\_getschedpolicy(&attr\_2, &policy);

`	`printf("Thread\_2's priority = %d\n", param.sched\_priority);

`	`switch (policy) {

`		`case SCHED\_FIFO:

`			`printf ("policy SCHED\_FIFO\n");

`			`break;

`		`case SCHED\_RR:

`			`printf ("policy SCHED\_RR\n");

`			`break;

`		`case SCHED\_OTHER:

`			`printf ("policy SCHED\_OTHER\n");

`			`break;

`		`case -1:

`			`perror ("policy SCHED\_GETSCHEDULER");

`			`break;

`		`default:

`			`printf ("policy Неизвестная политика планирования\n");

`	`}

`	`pthread\_create(&t1, &attr\_1, thread1, NULL);

`    `pthread\_create(&t2, &attr\_2, thread2, NULL);

`    `pthread\_join(t1, NULL);

`    `pthread\_join(t2, NULL);

`	`pthread\_attr\_destroy(&attr\_1);

`	`pthread\_attr\_destroy(&attr\_2);

}


**

# <a name="_toc190185320"></a>**Управление процессами и потоками с использованием сигналов**

Здесь из всего множества IPC мы остановимся только на изучении сигналов. Остальные средства подробно с многочисленными примерами кода для двух наиболее широко распространенных семейств ОС Unix и Windows описаны в другой книге:

` 	`*Душутина Е.В.* **Системное программное обеспечение. Межпроцессные взаимодействия в операционных системах**: учеб. пособие /Е.В. Душутина. – СПб.: Изд-во Политехн.ун-та, 2016. – 180 с.   (ISBN 978-5-7422-5401-0)

[URL:http://elib.spbstu.ru/](URL:http://elib.spbstu.ru/dl/2/4953.pdf) 

Сигналы позволяют осуществить самый примитивный способ коммуникации между двумя процессами. Сигналы в UNIX/Linux  используются для того, чтобы: сообщить процессу о том, что возникло какое-либо событие; или необходимо обработать исключительное состояние.

Изначально сигналы были разработаны для уведомления об ошибках. В дальнейшем их стали использовать и как простейшую форму межпроцессного взаимодействия (IPС), например, для синхронизации процессов или для передачи простейших команд от одного процесса другому.

Сигнал позволяет асинхронно передать уведомление о некотором произошедшем событии между процессами или между ядром системы и процессами. Это означает, что посредством сигналов можно выполнять две основные функции IPC: передачу информации и синхронизацию процессов или потоков. 

Для отправки и доставки сигнала требуется системный вызов. Для доставки – прерывание и его обработка. При этом требуется проведение довольно большого числа операций со стеком – копирование пользовательского стека в системную область, извлечение параметров и результатов работы системных вызовов и прерываний. Поскольку объем передаваемой информации при этом способе взаимодействия не велик, а затраты на его реализацию существенны, сигналы считаются одним из самых ресурсоемких способов IPC. 

Когда сигнал доставлен процессу, ОС прерывает выполнение процесса. Если процесс установил собственный *обработчик сигнала*, операционная система запускает этот обработчик, передав ему информацию о сигнале. Если процесс не установил обработчик, то выполняется обработчик по умолчанию.

Каждый сигнал имеет уникальное символьное имя «SIG…» и соответствующий ему номер, эти числовые константы (макроопределения СИ) определены в заголовочном файле signal.h. Числовые значения сигналов могут меняться от системы к системе, хотя большая их часть имеет в разных системах одни и те же значения. Утилита kill позволяет задавать сигнал как числом, так и символьным значением. Базовый перечень сигналов, поддерживаемый практически в любой POSIX-ориентированной ОС, составляет не более  тридцати двух (количество бит в тридцати двух-разрядном слове), и в большинстве современных систем их номера смещены к началу нумерации. Наряду с базовыми в POSIX ОС дополнительно может поддерживаться свой уникальный набор сигналов. 

Кроме того, с расширением стандарта POSIX и современными возможностями наращивания разрядной сетки (до шестидесяти четырех) перечень сигналов во многих ОС тоже расширился. Появился еще один тип сигналов – сигналы реального времени,  которые могут принимать значения между SIGRTMIN и SIGRTMAX включительно. POSIX требует, чтобы предоставлялось по крайней мере RTSIG\_MAX сигналов, и минимальное значение этой константы равно 8. 

Ознакомиться с полным перечнем сигналов можно с помощью команды kill -l в командном интерпретаторе той реализации ОС, с которой вы работаете, например, один из возможных вариантов:

$ kill –l

//Базовый список 


\1) SIGHUP 

\2) SIGINT 

\3) SIGQUIT

\4) SIGILL 

\5) SIGTRAP 

\6) SIGABRT 

\7) SIGBUS 

\8) SIGFPE 

\9) SIGKILL 

\10) SIGUSR1 

\11) SIGSEGV 

\12) SIGUSR2 

\13) SIGPIPE 

\14) SIGALRM 

\15) SIGTERM 

\16) SIGSTKFLT 

\17) SIGCHLD 

\18) SIGCONT 

\19) SIGSTOP 

\20) SIGTSTP 

\21) SIGTTIN 

\22) SIGTTOU 

\23) SIGURG 

\24) SIGXCPU 

\25) SIGXFSZ 

\26) SIGVTALRM 

\27) SIGPROF 

\28) SIGWINCH 

\29) SIGIO 

\30) SIGPWR 

\31) SIGSYS 


// Расширенный набор: 


\34) SIGRTMIN 

\35) SIGRTMIN+1 

\36) SIGRTMIN+2 

\37) SIGRTMIN+3 

\38) SIGRTMIN+4 

\39) SIGRTMIN+5 

\40) SIGRTMIN+6 

\41) SIGRTMIN+7 

\42) SIGRTMIN+8 

\43) SIGRTMIN+9 

\44) SIGRTMIN+10 

\45) SIGRTMIN+11

\46) SIGRTMIN+12 

\47) SIGRTMIN+13 

\48) SIGRTMIN+14 

\49) SIGRTMIN+15 

\50) SIGRTMAX-14 

\51) SIGRTMAX-13 

\52) SIGRTMAX-12 

\53) SIGRTMAX-11 

\54) SIGRTMAX-10 

\55) SIGRTMAX-9 

\56) SIGRTMAX-8 

\57) SIGRTMAX-7 

\58) SIGRTMAX-6 

\59) SIGRTMAX-5 

\60) SIGRTMAX-4 

\61) SIGRTMAX-3 

\62) SIGRTMAX-2 

\63) SIGRTMAX-1 

\64) SIGRTMAX 



Следует заметить, что именование базовых сигналов, как правило, совпадает в разных Unix-подобных ОС, чего нельзя сказать о нумерации, поэтому целесообразно сначала ознакомиться со списком.

Рассмотрим некоторые из сигналов базового списка:

\1) SIGHUP предназначен для того, чтобы информировать программу о потере связи с управляющим терминалом, так же и в том случае, если процесс-лидер сессии завершил свою работу\. Многие программы-демоны, у которых нет лидера сессии, так же обрабатывают этот сигнал\. В ответ на получение SIGHUP демон обычно перезапускается\. По умолчанию программа, получившая этот сигнал, завершается\.

\2) SIGINT посылается процессу, если пользователь с консоли отправил команду прервать процесс комбинацией клавиш (Ctrl+C) \.

\6) SIGABRT посылается программе в результате вызова функции abort(3)\. В результате программа завершается с сохранением на диске образа памяти\.

\9) SIGKILL завершает работу программы\. Программа не может ни обработать, ни игнорировать этот сигнал\.

\11) SIGSEGV посылается процессу, который пытается обратиться к не принадлежащей ему области памяти\. Если обработчик сигнала не установлен, программа завершается с сохранением на диске образа памяти\.

\15) SIGTERM вызывает «вежливое» завершение программы\. Получив этот сигнал, программа может выполнить необходимые перед завершением операции (например, высвободить занятые ресурсы)\. Получение SIGTERM свидетельствует не об ошибке в программе, а о желании ОС или пользователя завершить ее\.

\17) SIGCHLD посылается процессу в том случае, если его дочерний процесс завершился или был приостановлен\. Родительский процесс также получит этот сигнал, если он установил режим отслеживания сигналов дочернего процесса и дочерний процесс получил какой-либо сигнал\. По умолчанию сигнал SIGCHLD игнорируется\.

\18) SIGCONT возобновляет выполнение процесса, остановленного сигналом SIGSTOP\.

\19) SIGSTOP приостанавливает выполнение процесса\. Как и SIGKILL, этот сигнал не возможно перехватить или игнорировать\.

\20) SIGTSTP приостанавливает процесс по команде пользователя (Ctrl+Z)\.

\29) SIGIO сообщает процессу, что на одном из дескрипторов, открытых асинхронно, появились данные\. По умолчанию этот сигнал завершает работу программы\.

\10) и 12) SIGUSR1 и SIGUSR2 предназначены для прикладных задач и передачи ими произвольной информации\.

Сигнал может быть отправлен процессу либо ядром, либо другим процессом с помощью системного вызова kill():



`	`#include <signal.h>	

`	`int kill(pid\_t pid, int sig);	



Аргумент pid* адресует процесc, которому посылается сигнал. Аргумент sig* определяет тип отправляемого сигнала. С помощью системного вызова kill()** процесс может послать сигнал, как самому себе, так и другому процессу или группе процессов. В этом случае процесс, посылающий сигнал, должен иметь те же реальный и эффективный идентификаторы, что и процесс, которому сигнал отправляется. Разумеется, данное ограничение не распространяется на ядро или процессы, обладающие привилегиями суперпользователя. Они имеют возможность отправлять сигналы любым процессам системы.

Аналогичное действие можно произвести из командной строки в терминальном режиме, используя команду интерпретатора  

kill pid 

К генерации сигнала могут привести различные ситуации:

1\. Ядро отправляет процессу (или группе процессов) сигнал при нажатии пользователем определенных клавиш или их комбинаций. 

2\. Аппаратные особые ситуации, например, деление на 0, обращение недопустимой области памяти и т.д., также вызывают генерацию сигнала. Обычно эти ситуации определяются аппаратурой компьютера, и ядру посылается соответствующее уведомление (например, виде прерывания). Ядро реагирует на это отправкой соответствующего сигнала процессу, который находился в стадии выполнения, когда произошла особая ситуация.

3\. Определенные программные состояния системы или ее компонентов также могут вызвать отправку сигнала. В отличие от предыдущего случая, эти условия не связаны с аппаратной частью, а имеют программный характер. В качестве примера можно привести сигнал SIGALRM, отправляемый процессу, когда срабатывает таймер, ранее установленный с помощью вызова alarm().

Процесс может выбрать одно из трех возможных действий при получении сигнала:

1\. игнорировать сигнал,

2\. перехватить и самостоятельно обработать сигнал,

3\. позволить действие по умолчанию.

Текущее действие при получении сигнала называется *диспозицией сигнала*.

Порожденный вызовом fork() процесс *наследует диспозицию* сигналов от своего родителя. Однако при вызове exec() диспозиция всех перехватываемых сигналов будет установлена ядром на действие *по умолчанию*. Далее это будет представленоэкспериментально.

В ОС поддерживается ряд функций, позволяющих управлять диспозицией сигналов.

Наиболее простой в использовании является функция signal(). Она позволяет устанавливать и изменять диспозицию сигнала. 

#include <signal.h>

void (\*signal (int sig,  void (\*disp)(int)))(int);

Аргумент sig определяет сигнал, диспозицию которого нужно изменить. Аргумент disp определяет новую диспозицию сигнала. Возможны следующие три варианта:

|Значение|Назначение|
| :-: | :-: |
|SIG\_DFL|Указывает ядру, что при получении процессом сигнала необходимо вызвать системный обработчик, т. e. выполнить действие по умолчанию.|
|SIG\_IGN|Указывает, что сигнал следует игнорировать. Не все сигналы можно игнорировать.|
|Имя ф-ции|Указывает на определенную пользователем функцию-обработчик|

Возвращаемое функцией signal()значение может быть различным в различных ОС. В UNIX-подобных ОС, как правило, в случае успешного завершения signal() возвращает предыдущую диспозицию – это может быть функция-обработчик сигнала или системные значения SlG\_DFL или SIG\_IGN. Это значение в случае необходимости может быть использовано для  восстановления предыдущей диспозиции после однократного выполнения пользовательского обработчика. Для многократного использования требуется предусмотреть повторный вызов signal() в теле обработчика.

Приведем пример простейшего кода, который позволяет перехватить сигнал, генерирумый в результате нажатия комбинации клавиш (Ctrl+C).

// для процесса однократно

#include <stdio.h>

#include <signal.h>

void handler()

{

`   `puts("^C - signal received");

signal(SIGINT, SIG\_DFL); //восстановление диспозиции по умолчанию

}

int main()

{

`	`int pid, ppid;

`	`pid = getpid();

`	`ppid = getppid();

`	`printf("Current pid = %d and ppid = %d\n", pid, ppid);

`	`signal(SIGINT, handler);

`	`while(1);

`	`return 0;

}

Результат выполнения следующий:

user@debian:~/OS/Lab3/8$ ./main

Current pid = 9873 and ppid = 6303

^C - signal received

^C

user@debian:~/OS/Lab3/8 $

Сигнал ^C перехватывается и однократно вызывается обработчик handler, который выводит строку, оповещающую о получении сигнала, после чего возвращается обработчик SIGINT по умолчанию, результатом выполнения которого является принудительное завершение программы. Поэтому при повторном нажатии клавиш ^C, текущая программа прерывается, и выводится приглашение командной строки.

Для многократного срабатывания нужно скорректировать обработчик

void handler()

{

`	`static int i = 0;	

`	`printf("^C - signal received, i = %d\n", i);

`	`if (i++ == 5)  //количество срабатываний текущего обработчика

`		`signal(SIGINT, SIG\_DFL); //восстановление стандартного

`						     `//обработчика

}

Более гибкое управление сигналами предоставляет функция sigaction():

int sigaction( int sig,

`               `const struct sigaction \* act,

`               `struct sigaction \* oact );

Данная функция позволяет вызывающему процессу получить информацию или установить (или и то и другое) действие, соответствующее какому-либо сигналу или группе сигналов. При этом каждый сигнал ассоциируется с битом 32-х/(64-х) –разрядного  слова-маски, соответствующим номеру сигнала. 

Аргумент *sig* определяет тип сигнала (все типы сигналов определены в библиотеке signal.h). 

Аргумент act – если он не нулевой, то действие при  указанном сигнале изменятся.

Аргумент oact - если он не нулевой, то предыдущее действие при  указанном сигнале сохраняется в структуре типа sigaction, на которую указывает указатель oact.

Комбинация act* и* oact позволяет запрашивать или устанавливать новые действия при поступлении сигнала.

Состав структуры sigaction:

|void (\*sa\_handler)()|<p>адрес обработчика сигнала или </p><p>действие для незапрашиваемых сигналов</p>|
| :- | :- |
|<p>void (\*sa\_sigaction)(int signo, </p><p>siginfo\_t\* info,  </p><p>void\* other)</p>|<p>адрес обработчика сигнала или </p><p>действие для запрашиваемых сигналов</p>|
|sigset\_t sa\_mask|дополнительный набор сигналов, который при обработке поступившего сигнала будет заблокирован|
|int sa\_flags|специальные флаги для воздействия на режим работы сигнала|

Компоненты sa\_handler и sa\_sigaction структуры sigaction вызываются со следующими аргументами:

void handler(int signo, siginfo\_t\* info, void\* other); 

если обработчик сигнала представлен: 	void handler(int signo), 

то аргументы siginfo\_t\* info и void\* other будут игнорироваться.

Для работы с сигналами реального времени существует дополнительный набор функций. 

Выбор функции управления сигналами определяет свойства сигнала как средства IPC: signal()* обеспечивает так называемую *ненадежную* передачу сигнала, тогда как sigaction() гарантирует *надежную* передачу. Последнее означает, что если при возникновении сигнала система занята обработкой другого сигнала (назовем его «текущим»), то возникший сигнал не будет потерян, а его обработка будет отложена до окончания текущего обработчика. 

Разберем эти свойства более подробно на примерах.

**Ненадежные сигналы**

Пусть необходимо создать программу, позволяющую изменить диспозицию сигналов, а именно,  установить:  

` `- обработчик пользовательских сигналов SIGUSR1 и SIGUSR2;

` `- реакцию по умолчанию на сигнал SIGINT;

` `- игнорирование сигнала SIGCHLD;

Породить процесс-копию и уйти в ожидание сигналов. Обработчик сигналов должен содержать восстановление диспозиции и оповещение на экране о полученном (удачно или неудачно) сигнале и идентификаторе родительского процесса. Процесс-потомок, получив идентификатор родительского процесса, должен отправить процессу-отцу сигнал SIGUSR1 и извещение об удачной или неудачной отправке указанного сигнала. Остальные сигналы можно сгенерировать из командной строки.

Для решения поставленной задачи 

обе программы (родителя и потомка) зададим в одном файле. С одной стороны это делает код более компактным, с другой – упрощает наследование за счет использования только fork() –вызова и позволяет потомку скопировать диспозицию родителя.

Ветвление происходит сразу же за вызовом fork(). Если он вернул 0, значит, выполняется код программы-сына, иначе — код программы отца.

Исходный код (разместим в файле sigExam.c):

#include <stdio.h>

#include <signal.h>

#include <unistd.h>

#include <stdlib.h>

static void sigHandler(int sig) {

`	`printf("Catched signal %s\n",sig == SIGUSR1 ? "SIGUSR1" : "SIGUSR2");

`	`printf("Parent = %d\n",getppid());

`	`// востанавливаем старую диспозицию

`	`signal(sig,SIG\_DFL);

}

int main() {

`	`printf("\nFather started: pid = %i,ppid = %i\n",getpid(),getppid());

`	`signal(SIGUSR1,sigHandler);

`	`signal(SIGUSR2,sigHandler);

`	`signal(SIGINT,SIG\_DFL);

`	`signal(SIGCHLD,SIG\_IGN);

`	`int forkRes = fork();

`	`if(forkRes == 0) {

`	`// программа сын

`	`printf("\nSon started: pid = %i,ppid = %i\n",getpid(),getppid());

`	`// отправляем сигналы отцу

`	`if(kill(getppid(),SIGUSR1) != 0) {

`		`printf("Error while sending SIGUSR1\n");

`		`exit(1);

`	`}

`	`printf("Successfully sent SIGUSR1\n");

`	`return 0;

`	`}

`	`// программа отец

`	`wait(NULL);

`	`// ждем сигналов

`	`for(;;){

`		`pause();

`	`}	

`	`return 0;

}

Скомпилируем и выполним программу:

dе@dе:~/lab4$ cc -o sigExam sigExam.c

dе@dе:~/lab4$ ./sigExam 

Father started: pid = 14589,ppid = 12231

Son started: pid = 14590,ppid = 14589

Successfully sent SIGUSR1

Catched signal SIGUSR1

Parent = 12231

Процесс-потомок отправил сигнал SIGUSR1, а процесс-отец его успешно принял. Отправим еще 3 сигнала процессу-отцу: SIGCHLD, SIGUSR2, SIGINT:

dе@dе:~/lab4/sig$ kill -SIGUSR2 14589

dе@dе:~/lab4/sig$ kill -SIGCHLD 14589

dе@dе:~/lab4/sig$ kill -SIGINT 14589

Результат:

Catched signal SIGUSR2

Parent = 12231

de@de:~/lab4/sig$ 

Сигнал SIGUSR2 также был «пойман», на сигнал SIGCHLD не последовало никакой реакции (так как мы задали для него реакцию игнорирования), и сигнал SIGINT привел к завершению работы.

Запустим программу еще раз и дважды отправим ей сигнал SIGUSR2:

de@de:~/lab4/sig$ ./sigExam 

Father started: pid = 16225,ppid = 12231

Son started: pid = 16226,ppid = 16225

Successfully sent SIGUSR1

Catched signal SIGUSR1

Parent = 12231

Catched signal SIGUSR2

Parent = 12231

User defined signal 2

В результате первый сигнал SIGUSR2 был «пойман», а второй обработался по умолчанию. Это происходит потому, что в обработчике после первого приема сигнала происходит восстановление диспозиции сигналов. Аналогичная ситуация была бы при двукратной отправке процессу сигнала SIGUSR1.

**Для самостоятельного исследования** повторите эксперимент с другими сигналами

` `1) для процессов, порождаемых в разных файлах, 

`       `2) а также для потоков одного процесса

`       `3) и потоков разных процессов.

**Надежные сигналы**

Рассмотрим пример с *отложенной* обработкой сигналов. 

Пусть необходимо создать программу, позволяющую продемонстрировать возможность временного блокирования сигнала (например, SIGINT) и его последующей обработки. 

Решение.

Вся необходимая для управления сигналами информация передается через указатель на структуру *sigaction*. Блокировку реализуем, вызвав "засыпание" процесса на одну минуту из обработчика пользовательских сигналов. В основной программе установим диспозицию этих сигналов. С рабочего терминала отправим процессу sigact сигнал SIGUSR1 или SIGUSR2, а затем сигнал SIGINT. 

Напомним, что сигнал SIGINT можно генерировать несколькими способами: комбинацией клавиш CTRL C, командой kill из командной строки или системной функцией kill().

Исходный код (sigact.c):

#include <stdio.h>

#include <signal.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <unistd.h>

#include <stdlib.h>

#include <fcntl.h>

void (\*mysig(int sig,void (\*hnd)(int)))(int) {

`	`// надежная обработка сигналов

`	`struct sigaction act,oldact;

`	`act.sa\_handler = hnd;

`	`sigemptyset(&act.sa\_mask);

`	`sigaddset(&act.sa\_mask,SIGINT);

`	`act.sa\_flags = 0;

`	`if(sigaction(sig,&act,0) < 0)

`		`return SIG\_ERR;

`	`return act.sa\_handler;

}

void hndUSR1(int sig) {

`	`if(sig != SIGUSR1) {

`		`printf("Catched bad signal %d\n",sig);

`		`return;

`	`}

`	`printf("SIGUSR1 catched\n");

`	`sleep(60);

}

int main() {

`	`mysig(SIGUSR1,hndUSR1);

`	`for(;;) {

`		`pause();

`	`}

`	`return 0;

}

Результаты выполнения:

de@de:~/lab4/sig$ cc -w -o sigact sigact.c

de@de:~/lab4/sig$ ./sigact &

[1] 25329

de@de:~/lab4/sig$ kill -SIGUSR1 %1

SIGUSR1 catched

de@de:~/lab4/sig$ kill -SIGINT %1

de@de:~/lab4/sig$ jobs

[1]+  Running                 ./sigact &

de@de:~/lab4/sig$ jobs

[1]+  Interrupt               ./sigact

Чтобы иметь возможность отправить сигналы с терминала следует запустить программу в фоновом режиме (вторая строчка под рубрикой «результаты выполнения»). По результатам сигнал SIGUSR1 принят корректно, но после посылки сигнала SIGINT программа продолжала выполняться еще минуту, и только после этого завершилась. В этом отличие надежной обработки сигналов от ненадежной: есть возможность отложить прием некоторых других сигналов. Отложенные таким образом сигналы записываются в маску PENDING и обрабатываются после завершения обработки сигналов, которые отложили обработку. 

Остановимся на этом чуть подробнее. Сигналы можно блокировать и разблокировать. Когда сигнал заблокирован, его обработчик не вызывается, даже если имеется сигнал, требующий обработки. Сигнал как бы ожидает обработки (pending signal - "сигнал, ожидающий обработки", "висячий сигнал"). Обработчик сигнала будет вызван сразу, как только процесс разблокирует этот сигнал. Каждый сигнал в каждый момент времени у каждого процесса либо заблокирован, либо разблокирован. *Блокировка* сигнала означает *временное игнорирование* сигнала. Отличие от диспозиции игнорирования в том, что если процесс никогда не хочет получать данный сигнал, он его игнорирует, т.е. ОС при возникновении данного сигнала для данного процесса его просто отменяет (аннулирует). Если же для процесса нежелательно получать тот или иной сигнал лишь в течение некоторого конечного интервала времени, то он его блокирует, а ОС сохраняет информацию о наличии сигнала для данного процесса и доставляет его (сигнал) процессу, когда последний разблокирует этот сигнал. 

Если основная программа и обработчики сигналов имеют общие ресурсы, то на время, пока основная программа с ними работает (читает, пишет), соответствующие сигналы в большинстве случаев должны быть заблокированы. Кроме того, сигнал может поступить во время исполнения обработчика этого самого сигнала, поэтому на время работы обработчика сигнала этот сигнал желательно блокировать.

Совокупность всех сигналов, которые в данный момент времени заблокированы, называется *маской сигналов* (signal mask). Каждому процессу устанавливается своя маска сигналов; при создании процесса она наследуется от родительского процесса. Для манипуляций с маской сигналов предназначен системный вызов sigprocmask().

Механизм ненадёжных сигналов не позволяет откладывать обработку других сигналов (можно лишь установить игнорирование некоторых сигналов на время обработки).

Теперь попробуем изменить обработчик сигнала так, чтобы из него производилась отправка другого сигнала. 

Пусть из обработчика сигнала SIGUSR1 функцией kill() генерируется сигнал SIGINT. Проанализируем наличие и очередность обработки сигналов.

Исходный код программы остается прежним за исключением содержимого обработчика, его и приведем.

Исходный код** обработчика сигнала

void hndUSR1(int sig) {

`	`if(sig != SIGUSR1) {

`		`printf("Catched bad signal %d\n",sig);

`		`return;

`	`}

`	`printf("SIGUSR1 catched, sending SIGINT\n");

`	`kill(getpid(),SIGINT);

`	`sleep(10);

}

Результаты выполнения программы:

de@de:~/lab4/sig$ cc -w -o sigact2 sigact2.c

de@de:~/lab4/sig$ ./sigact2 &

[1] 28822

de@de:~/lab4/sig$ kill -SIGUSR1 %1

de@de:~/lab4/sig$ SIGUSR1 catched, sending SIGINT

jobs

[1]+  Running                 ./sigact2 &

de@de:~/lab4/sig$ jobs

[1]+  Running                 ./sigact2 &

de@de:~/lab4/sig$ kill -SIGINT %1

[1]+  Interrupt               ./sigact2

При генерации сигнала (в данном случае SIGINT) из обработчика другого сигнала обработка сгенерированного сигнала задерживается до конца выполнения текущего обработчика (как и в предыдущем эксперименте).

При получении сигнала *активным* процессом, он продолжает работать, а *пассивный* – превращается  в зомби. Это легко демонстрируется экспериментально. 

# <a name="_toc190185321"></a>**Наследование диспозиции сигналов**

Проанализируем *наследование диспозиции сигналов*  при создании процесса на этапах fork() и exec(). 

Ниже представлена программа, которая меняет диспозицию сигналов, а именно, задает обработчик пользовательских сигналов SIGUSR1 и SIGUSR2, ее состав при функционировании:

родительский процесс порождает процесс-копию с помощью fork(), и уходит в ожидание сигналов; 

процесс-потомок находится в пассивном состоянии, при этом не ждет никаких сигналов, и соответственно, не назначает им никаких обработчиков;

обработчик сигналов SIGUSR1 и SIGUSR2 содержит восстановление диспозиции и оповещение на экране об удачно или неудачно полученном сигнале и идентификаторе родительского процесса; 

сигналы генерируются из командной строки.

Программы родителя и потомка задаются в одном файле, где ветвление происходит после вызова fork()  (если он вернул 0, значит выполняется код программы-сына, которая посылает сигнал родительскому процессу, иначе — код программы-отца). При этом, за счет использования fork() потомок должен наследовать диспозицию сигналов от родителя.

**sig\_father.c**

#include <stdio.h>

#include <stdlib.h>

#include <signal.h>

static void handler(int sig) {

`	`printf("Catched signal %s\n", sig == SIGUSR1 ? "SIGUSR1" : "SIGUSR2");

`	`printf("Parent = %d\n", getppid());

`	`signal(sig, SIG\_DFL);

}

int main() {

`	`printf("Father's params: pid = %d, ppid = %d\n", getpid(), getppid());

`	`signal(SIGUSR1, handler);

`	`signal(SIGUSR2, handler);

`	`if (fork() == 0) {

`		`printf("Son's params: pid = %d, ppid = %d\n", getpid(), getppid());

`		`while(1)

`			`pause(); 		

`		`return 0;

`	`}

`	`wait(NULL);

`	`while(1)

`		`pause();

`	`return 0;

}

Результаты выполнения программы:

Запустим выполнение программы в фоновом режиме.

user@debian:~/OS/Lab3/8/signals$ ./father &

[1] 30793

Father's params: pid = 30793, ppid = 29981

Son's params: pid = 30794, ppid = 30793

Отправим сигнал процессу-родителю:

user@debian:~/OS/Lab3/8/signals$ kill -SIGUSR1 30793

Catched signal SIGUSR1

Parent = 29981

Теперь отправим тот же сигнал процессу-потомку:

user@debian:~/OS/Lab3/8/signals$ kill -SIGUSR1 30794

Catched signal SIGUSR1

Parent = 30793

user@debian:~/OS/Lab3/8/signals$ ps f

`  `PID TTY      STAT   TIME COMMAND

30683 pts/1    Ss+    0:00 bash

29981 pts/0    Ss     0:01 bash

30793 pts/0    S      0:00  \\_ ./father

30794 pts/0    S      0:00  |   \\_ ./father

30796 pts/0    R+     0:00  \\_ ps f

При отправке сигнала разным процессам, результат совпадает, потомок использует тот же обработчик, что свидетельствует  о наследовании диспозиции при порождении потомка на этапе  fork().

Рассмотрим еще один пример:

user@debian:~/OS/Lab3/8/signals$ ./father &

[1] 30823

Father's params: pid = 30823, ppid = 29981

Son's params: pid = 30824, ppid = 30823

user@debian:~/OS/Lab3/8/signals$ kill -SIGUSR1 30823

Catched signal SIGUSR1

Parent = 29981

user@debian:~/OS/Lab3/8/signals$ kill -SIGUSR1 30823

[1]+  Определяемый пользователем сигнал 1         ./father

user@debian:~/OS/Lab3/8/signals$ kill -SIGUSR1 30824

Catched signal SIGUSR1

Parent = 1

user@debian:~/OS/Lab3/8/signals$ kill -SIGUSR1 30824

Здесь видно, что диспозиция сигналов для дочернего процесса, созданного с помощью fork(), сохраняется даже после завершения работы процесса-родителя.

Повторим эксперимент для процесса-родителя, порождающего дочерний процесс с помощью пары вызовов fork() и exec():

**sig\_father.c**

#include <stdio.h>

#include <stdlib.h>

#include <signal.h>

#include <unistd.h>

static void handler(int sig) {

`	`printf("Catched signal %s\n", sig == SIGUSR1 ? "SIGUSR1" : "SIGUSR2");

`	`printf("Parent = %d\n", getppid());

`	`signal(sig, SIG\_DFL);

}

int main() {

`	`printf("Father's params: pid = %d, ppid = %d\n", getpid(), getppid());

`	`signal(SIGUSR1, handler);

`	`signal(SIGUSR2, handler);

`	`if (fork() == 0)

`		`execl("son", "son", NULL);

`	`wait(NULL);

`	`while(1)

`		`pause();

`	`return 0;

}

**sig\_son.c**

#include <stdio.h>

#include <stdlib.h>

#include <signal.h>



int main() {

`	`printf("Son's params: pid = %d, ppid = %d\n", getpid(), getppid());

`	`while(1)

`		`pause();

`	`return 0;

}

По сравнению с предыдущей программой потомок загружается из файла son.c. Порождение потомка происходит с использованием двух функций fork() и execl().

user@debian:~/OS/Lab3/8/signals/2$ gcc -o son son.c

user@debian:~/OS/Lab3/8/signals/2$ gcc -o father father.c

user@debian:~/OS/Lab3/8/signals/2$ ./father &

[1] 30907

Father's params: pid = 30907, ppid = 29981

Son's params: pid = 30908, ppid = 30907

Отправка сигнала SIGUSR1 процессу-родителю:

user@debian:~/OS/Lab3/8/signals/2$ kill -SIGUSR1 30907

Catched signal SIGUSR1

Parent = 29981

user@debian:~/OS/Lab3/8/signals/2$ ps f

`  `PID TTY      STAT   TIME COMMAND

30683 pts/1    Ss+    0:00 bash

29981 pts/0    Ss     0:01 bash

30907 pts/0    S      0:00  \\_ ./father

30908 pts/0    S      0:00  |   \\_ son

30910 pts/0    R+     0:00  \\_ ps f

Отправка того же сигнала процессу-потомку:

user@debian:~/OS/Lab3/8/signals/2$ kill -SIGUSR1 30908

user@debian:~/OS/Lab3/8/signals/2$ ps f

`  `PID TTY      STAT   TIME COMMAND

30683 pts/1    Ss+    0:00 bash

29981 pts/0    Ss     0:01 bash

30907 pts/0    S      0:00  \\_ ./father

30912 pts/0    R+     0:00  \\_ ps f

user@debian:~/OS/Lab3/8/signals/2$ kill -SIGUSR1 30907

[1]+ Определяемый пользователем сигнал 1      ./father

В соответствии с полученными результатами при отправке сигнала процессу-отцу срабатывает его обработчик, а при отправке того же сигнала процессу-потомку диспозиция этого сигнала не сохраняется, и срабатывает обработчик по умолчанию. Из этого можно сделать вывод, что при создании процесса с помощью fork() и exec() диспозиция сигналов не наследуется.

**nohup(1)** — утилита, позволяющая запустить команду, невосприимчивую к сигналам потери связи (hungup), и чей вывод будет направлен не на терминал, а в файл nohup.out. Таким образом, команда будет выполняться в фоновом режиме даже тогда, когда пользователь выйдет из системы.

Запустим длительный процесс с помощью nohup:

user@debian:~/OS/Lab3/10/5$ nohup ./main &

[1] 3257

user@debian:~/OS/Lab3/10/5$ nohup  ввод игнорируется, вывод добавляется в «nohup.out»

main.c

#include <stdio.h>

void main()

{

`    `int i;

`	`for(i = 0; i < 999999999999; i++);

}

Завершим сеанс работы и снова войдем в систему.

При выводе команды ps xa получим следующий результат:

user@debian:~$ ps xa

`  `PID TTY      STAT   TIME COMMAND

...

` `3257 ?        R      0:51 ./main

…

т.е. при выходе из системы, данный процесс не завершился: команда nohup позволила данной команде игнорировать сигнал SIGHUP, который рассылается процессам при выходе из системы.

При выполнении следующей программы с командой nohup:

#include <stdio.h>

void main()

{

`    `int i;

`	`for(i = 0; i < 10; i++)

`		`printf("%d ", i);

}

результат выводится в nohup.out:

$ nohup ./main &

[1] 4876

$ nohup: ввод игнорируется, вывод добавляется в «nohup.out»

cat nohup.out

0 1 2 3 4 5 6 7 8 9

` `[1]+  Exit 2                  nohup ./main

# <a name="_toc190185322"></a>**Сигналы POSIX реального времени**

Некоторые реализации POSIX ОС могут обрабатывать все сигналы как сигналы реального времени, но для UNIX-подобных ОС это не является обязательным. Если мы хотим, чтобы сигналы ***гарантированно*** обрабатывались как сигналы реального времени, мы должны: 

использовать сигналы с номерами в диапазоне от SIGRTMIN до SIGRTMAX 

указать флаг SA\_SIGINFO при вызове ***sigaction()*** с установкой обработчика сигнала

сформировать и указать обработчик сигнала реального времени, устанавливаемый с флагом SA\_SIGINFO, объявляется как:

void func(int *signo,* siginfo\_t *\*info,* void *\*context*);   где

*signo —* номер сигнала, 

siginfo\_t — структура, определяемая как

typedef struct {

` 	`int si\_signo; /\* то же, что и signo \*/

`	`int si\_code; /\* SI\_{USER,QUEUE,TIMER,ASYNCIO,MESGQ} \*/

` 	`union sigval si\_value; /\* целое или указатель от отправителя \*/

`	`} siginfo\_t;

на что указывает *context* — зависит от реализации.

Таким образом, сигналы реального времени несут больше информации, чем прочие сигналы (при отправке сигнала, не обрабатываемого как сигнал реального времени, единственным аргументом обработчика является номер сигнала).

SIGRTMIN и SIGRTMAX – это еще и макросы  (вызывающие *sysconf*), которые позволяют изменять сами эти значения.

# <a name="_toc190185323"></a>**Характеристики сигналов реального времени**

Сигналы помещаются в очередь. 

Если сигнал будет порожден несколько раз, он будет несколько раз получен адресатом. Более того, повторения одного и того же сигнала доставляются в порядке очереди (FIFO). Если же сигналы в очередь не помещаются, неоднократно порожденный сигнал будет получен лишь один раз.

Когда в очередь помещается множество неблокируемых сигналов в диапазоне SIGRTMIN—SIGRTMAX, сигналы с меньшими номерами доставляются раньше сигналов с большими номерами. То есть сигнал с номером SIGRTMIN имеет «больший приоритет», чем сигнал с номером SIGRTMIN+1, и т.д.

Напомним, если одновременно посылается несколько обычных одинаковых сигналов (из первых 32-х сигналов полной линейки), то они будут «слиты» в один сигнал, т. е. обработчик вызовется только один раз.

Сигналы реального времени обеспечивают доставку множества одинаковых, отосланных поочередно, сигналов (они не будут сливаться) и дают гарантию упорядоченной доставки: если поочередно послать несколько сигналов реального времени, то они все будут обработаны, а если отправленные сигналы различны, то они будут упорядочены — сигналы с меньшим номером придут и будут обработаны раньше, чем сигналы с большим. Это легко проверить опытным путем, ниже представлена примерная структура кода, который можно использовать для отправки сигналов разных типов из одной нити в другую и дальнейшего анализа приоритетности сигналов.

#include <signal.h>

#include <pthread.h>

#include <stdio.h>

#include <sys/types.h>

#include <linux/unistd.h>

#include <sys/syscall.h>

pthread\_t t1, t2;

void hnd (int sig) {

`	`if(sig == SIGUSR1) {

`		`printf("Catched SIGUSR1 %d\n",sig);

`		`signal(sig,hnd); //восстановление диспозиции с нашим обработчиком

`		`return;

`	`}

`	`if(sig == SIGUSR2) {

`		`printf("Catched SIGUSR2  %d\n",sig);

`		`signal(sig, hnd);

`		`return;

`	`}

`	`if(sig == SIGRTMIN+1) {

`		`printf("Catched SIGRTMIN+1  %d\n",sig);

`		`signal(sig, hnd);

`		`return;

`	`}

// далее аналогично для других сигналов

…

}

void\* thread1()

{

`    `int i, count = 0;

`	`int tid, pid;

`	`tid = syscall(SYS\_gettid);

`	`pid = getpid();

`    `printf("Thread\_1 with thread id = %d and pid = %d is started\n", tid, pid);

`	`int n=2; //можно установить любым

for (i = 0; i < n; i++)

`    	`{

`        	`count += 1;

`	`printf("Thread\_1: step %d \n", count);

sleep(5);

// отправка обычных сигналов из первой нити во вторую

`	`pthread\_kill(t2, SIGUSR2); 

`	`pthread\_kill(t2, SIGUSR1);	

`	`pthread\_kill(t2, SIGUSR1); 

`	`pthread\_kill(t2, SIGRTMIN+3);// отправка сигналов реального времени

`	`pthread\_kill(t2, SIGRTMIN+1);	

`	`pthread\_kill(t2, SIGRTMIN+5);

` 	`pthread\_kill(t2, SIGRTMIN+1);	

`    `}

`  `}

void\* thread2()

{

`    `int i, count = 0;

`    `int tid, pid;

`    `tid = syscall(SYS\_gettid);

`    `pid = getpid();

`    `printf("Thread\_2 with thread id = %d and pid = %d is started\n", tid, pid);

`    `int m=10; //можно подобрать на свое усмотрение, чтобы все сигналы //успевали доставиться 

`    `for (i = 0; i < m; i++) 

`    `{

`        `count += 1;

`		`sleep(1);

`		`printf("Thread\_2: step %d\n", count);

`    `}

}

void main()

{	

`    `pthread\_create(&t1, NULL, thread1, NULL);

`    `pthread\_create(&t2, NULL, thread2, NULL);

`    `pthread\_join(t1, NULL);

`    `pthread\_join(t2, NULL);

}

Как уже говорилось ранее, при отправке сигнала потоку посредством команды или функции kill() происходит завершение не только этого потока, но и всего многопоточного приложения в целом. Для завершения отдельной нити необходимо использовать функции, ориентированные на работу с потоками (они были описаны ранее), а также функцию pthread\_exit(). Модификация обработчика сигнала посредством дополнения его этой функцией, позволит завершать нить по факту срабатывания обработчика в ответ на возникновение сигнала: 

void handler()

{

`	`puts("Signal's received");

`	`**pthread\_exit**(NULL);

}

void\* threadn ()

{

`    	`int i, count = 0;

`	`int tid, pid;

`	`tid = syscall(SYS\_gettid);

`	`pid = getpid();

`    	`// здесь размещаем собственно полезный код нити

`	`signal(SIGUSR1, handler);

`	`}

Вызов pthread\_exit приводит к завершению нити, вызвавшей эту функцию. Так как в программе возникновение сигнала ожидается в threadn(), то именно этот поток и завершается в результате выполнения обработчика в его контексте, а другие потоки продолжают выполнение.

Далее изложение по ссылке:

*Душутина Е.В.* **Системное программное обеспечение. Межпроцессные взаимодействия в операционных системах**: учеб. пособие /Е.В. Душутина. – СПб.: Изд-во Политехн.ун-та, 2016. – 180 с.   (ISBN 978-5-7422-5401-0)

[URL:http://elib.spbstu.ru/](URL:http://elib.spbstu.ru/dl/2/4953.pdf) 
