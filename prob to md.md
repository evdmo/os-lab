


[Системное программирование в ОС	](#_toc190170005)

[Средства межпроцессного взаимодействия в LINUX ОС	](#_toc190170006)

[1. Сигналы	](#_toc190170007)

[Сигналы POSIX реального времени](#_toc190170008)

[2. Неименованные каналы	](#_toc190170009)

[3. Именованные каналы	](#_toc190170010)

[4. Очереди сообщений	](#_toc190170011)

[5. Семафоры и разделяемая память	](#_toc190170012)

[6. Сокеты	](#_toc190170013)


























<a name="_toc190170005"></a>**Системное программирование в ОС** 

<a name="_toc190170006"></a>**Средства межпроцессного взаимодействия в LINUX ОС**



В Unix-подобных ОС  средства межпроцессных взаимодействий (IPC – Inter  Process Communication) включают следующий базовый набор: 

- сигналы,
- анонимные (неименованные) каналы (иногда их называют программные),
- именованные каналы,
- очереди сообщений,
- семафоры  
- разделяемая память,
- сокеты.

IPC в той или иной степени совмещают функции уведомления о событии и его обработки, передачи информации и синхронизации. В Unix-подобных ОС ***все перечисленные средства, за исключением сокетов, являются локальными***, т.к. используют буферизацию в пространстве ядра и адресуются в локальном пространстве памяти. 

Для исследования IPC на примерах используем ОС Linux (Ubuntu).

`	`**<a name="_toc190170007"></a>1. Сигналы**

Сигналы позволяют осуществить самый примитивный способ коммуникации между двумя процессами. Сигналы в системе UNIX используются для того, чтобы: сообщить процессу о том, что возникло асинхронное событие; или необходимо обработать исключительное состояние.

Изначально сигналы были разработаны для уведомления об ошибках. В дальнейшем их стали использовать и как простейшую форму межпроцессного взаимодействия (IPС), например, для синхронизации процессов или для передачи простейших команд от одного процесса другому.
`        `Сигнал позволяет передать уведомление о некотором произошедшем событии между процессами или между ядром системы и процессами. Это означает, что посредством сигналов можно выполнять две основные функции IPC: передачу информации и синхронизацию процессов или потоков. 

Для отправки и доставки сигнала требуется системный вызов. Для доставки – прерывание и его обработка. При этом требуется проведение довольно большого числа операций со стеком – копирование пользовательского стека в системную область, извлечение параметров и результатов работы системных вызовов и прерываний. Поскольку объем передаваемой информации при этом способе взаимодействия не велик, а затраты на его реализацию существенны, сигналы считаются одним из самых ресурсоемких способов IPC. 

Каждый сигнал имеет уникальное символьное имя и соответствующий ему номер. Базовый перечень сигналов, поддерживаемый практически в любой POSIX-ориентированной ОС, составляет не более  тридцати двух (количество бит в тридцати двух-разрядном слове) и в большинстве современных систем их номера смещены к началу нумерации. Наряду с базовыми в POSIX ОС дополнительно может поддерживаться свой уникальный набор сигналов. 

Кроме того, с расширением стандарта POSIX и современными возможностями наращивания разрядной сетки (до шестидесяти четырех) перечень сигналов во многих ОС тоже расширился. Появился еще один тип сигналов – сигналы реального времени,  которые могут принимать значения между SIGRTMIN и SIGRTMAX включительно. POSIX требует, чтобы предоставлялось по крайней мере RTSIG\_MAX сигналов, и минимальное значение этой константы равно 8. 

Ознакомиться с полным перечнем сигналов можно с помощью команды *kill -l* в командном интерпретаторе той реализации ОС, с которой вы работаете, например, один из возможных вариантов:
```c
$ kill -l 

\1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 

\6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 

\11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 

\16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 

\21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 

\26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 

\31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 

\37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 

\41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 

\45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 

\53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 

\57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 

\61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 

```

Следует заметить, что именование базовых сигналов, как правило, совпадает в разных Unix-подобных ОС, чего нельзя сказать о нумерации, поэтому целесообразно сначала ознакомиться со списком.

Кроме того, сигнал может быть отправлен процессу либо ядром, либо другим процессом с помощью системного вызова kill():	
```c
`	`#include <signal.h>	

`	`int kill(pid\_t pid, int sig);	                 
```
Аргумент *pid* адресует процесc, которому посылается сигнал. Аргумент *sig* определяет тип отправляемого сигнала. С помощью системного вызова *kill()* процесс может послать сигнал, как самому себе, так и другому процессу или группе процессов. В этом случае процесс, посылающий сигнал, должен иметь те же реальный и эффективный идентификаторы, что и процесс, которому сигнал отправляется. Разумеется, данное ограничение не распространяется на ядро или процессы, обладающие привилегиями суперпользователя. Они имеют возможность отправлять сигналы любым процессам системы.

Аналогичное действие можно произвести из командной строки в терминальном режиме, используя команду интерпретатора  
```c
kill pid 
```
К генерации сигнала могут привести различные ситуации:

1\. Ядро отправляет процессу (или группе процессов) сигнал при нажатии пользователем определенных клавиш или их комбинаций. 

2\. Аппаратные особые ситуации, например, деление на 0, обращение недопустимой области памяти и т.д., также вызывают генерацию сигнала. Обычно эти ситуации определяются аппаратурой компьютера, и ядру посылается соответствующее уведомление (например, виде прерывания). Ядро реагирует на это отправкой соответствующего сигнала процессу, который находился в стадии выполнения, когда произошла особая ситуация.

3\. Определенные программные состояния системы или ее компонентов также могут вызвать отправку сигнала. В отличие от предыдущего случая, эти условия не связаны с аппаратной частью, а имеют программный характер. В качестве примера можно привести сигнал SIGALRM, отправляемый процессу, когда срабатывает таймер, ранее установленный с помощью вызова alarm().

Процесс может выбрать одно из трех возможных действий при получении сигнала:

1\. игнорировать сигнал,

2\. перехватить и самостоятельно обработать сигнал,			

3\. позволить действие по умолчанию.

Текущее действие при получении сигнала называется **диспозицией сигнала**.

Порожденный вызовом *fork()* процесс *наследует диспозицию* сигналов от своего родителя.  Однако при вызове *exec()* диспозиция всех перехватываемых сигналов будет установлена ядром на действие *по умолчанию*. 

В ОС поддерживается ряд функций, позволяющих управлять диспозицией сигналов.

Наиболее простой в использовании является функция *signal().* Она позволяет устанавливать и изменять диспозицию сигнала. 
```c
#include <signal.h>

void (\*signal (int sig,  void (\*disp)(int)))(int);
```
Аргумент sig определяет сигнал, диспозицию которого нужно изменить. Аргумент disp определяет новую диспозицию сигнала. Возможны следующие три варианта:

|Значение|Назначение|
| :-: | :-: |
|SIG\_DFL    |Указывает ядру, что при получении процессом сигнала необходимо вызвать системный обработчик, т. e. выполнить действие по умолчанию.|
|SIG\_IGN    |Указывает, что сигнал следует игнорировать. Не все сигналы можно игнорировать.|
|Имя ф-ции   |Указывает на определенную пользователем функцию-обработчик|

Возвращаемое функцией *signal()* значение может быть различным в различных ОС. В UNIX-подобных ОС, как правило, в случае успешного завершения *signal()* возвращает предыдущую диспозицию - это может быть функция-обработчик сигнала или системные значения SlG\_DFL или SIG\_IGN. Это значение в случае необходимости может быть использовано для  восстановления предыдущей диспозиции после однократного выполнения пользовательского обработчика. Для многократного использования требуется предусмотреть повторный вызов *signal()* в теле обработчика.

Более гибкое управление сигналами предоставляет функция *sigaction()*:
```c
int sigaction( int sig,

`               `const struct sigaction \* act,

`               `struct sigaction \* oact );
```
Данная функция позволяет вызывающему процессу получить информацию или установить (или и то и другое) действие, соответствующее какому-либо сигналу или группе сигналов. При этом каждый сигнал ассоциируется с битом 32-х/(64-х) –разрядного слова-маски, соответствующим номеру сигнала. 

Аргумент *sig* определяет тип сигнала (все типы сигналов определены в библиотеке signal.h). 

Аргумент *act* – если он не нулевой, то действие при  указанном сигнале изменятся.

Аргумент *oact* - если он не нулевой, то предыдущее действие при  указанном сигнале сохраняется в структуре типа *sigaction*, на которую указывает указатель *oact*.

Комбинация *act* и *oact* позволяет запрашивать или устанавливать новые действия при поступлении сигнала.

Состав структуры *sigaction*:

|void (\*sa\_handler)()|<p>адрес обработчика сигнала или </p><p>действие для незапрашиваемых сигналов</p>|
| - | - |
|<p>void (\*sa\_sigaction)(int signo, </p><p>siginfo\_t\* info,  void\* other)</p>|<p>адрес обработчика сигнала или </p><p>действие для запрашиваемых сигналов</p>|
|sigset\_t sa\_mask|дополнительный набор сигналов, который будет заблокирован при обработке поступившего сигнала|
|int sa\_flags|специальные флаги для воздействия на режим работы сигнала|

Компоненты sa\_handler и sa\_sigaction структуры sigaction вызываются со следующими аргументами:
```c
void handler(int signo, siginfo\_t\* info, void\* other); 
```
если обработчик сигнала представлен:	void handler(int signo), 

то аргументы siginfo\_t\* info и void\* other будут игнорироваться.

Для работы с сигналами реального времени существует дополнительный набор функций. 

Выбор функции управления сигналами определяет свойства сигнала как средства IPC: *signal()*обеспечивает так называемую *ненадежную* передачу сигнала, тогда как *sigaction()* гарантирует *надежную* передачу. Последнее означает, что если при возникновении сигнала система занята обработкой другого сигнала (назовем его «текущим»), то возникший сигнал не будет потерян, а его обработка будет отложена до окончания текущего обработчика. 

Разберем эти свойства более подробно **на примерах**.

**Ненадежные сигналы**

Пример. ТЗ: Создать программу, позволяющую изменить диспозицию сигналов, а именно,  установить:  

` `- обработчик пользовательских сигналов SIGUSR1 и SIGUSR2;

` `- реакцию по умолчанию на сигнал SIGINT;

` `- игнорирование сигнала SIGCHLD;

Породить процесс-копию и уйти в ожидание сигналов. Обработчик сигналов должен содержать восстановление диспозиции и оповещение на экране о полученном (удачно или неудачно) сигнале и идентификаторе родительского процесса. Процесс-потомок, получив идентификатор родительского процесса, должен отправить процессу-отцу сигнал SIGUSR1 и извещение об удачной или неудачной отправке указанного сигнала. Остальные сигналы можно сгенерировать из командной строки.

**Исходный код** (в файле sigExam.c):
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

static void sigHandler(int sig) {

`  `printf("Catched signal %s\n",sig == SIGUSR1 ? "SIGUSR1": "SIGUSR2");

`	`printf("Parent = %d\n",getppid());
`	`// востанавливаем старую диспозицию
`	`signal(sig,SIG\_DFL);
}

int main()
{
`   `printf("\nFather started: pid = %i,ppid = %i\n",getpid(),getppid());

`	`signal(SIGUSR1,sigHandler);
`	`signal(SIGUSR2,sigHandler);
`	`signal(SIGINT,SIG\_DFL);
`	`signal(SIGCHLD,SIG\_IGN);

`	`int forkRes = fork();
`	`if(forkRes == 0) {
`	`// программа-потомок
`	`printf("\nSon started: pid = %i,ppid = %i\n",getpid(),getppid());
`	`// отправляем сигналы родителю
`	`if(kill(getppid(),SIGUSR1) != 0) {
`		`printf("Error while sending SIGUSR1\n");
`		`exit(1);
`	`}

`	`printf("Successfully sent SIGUSR1\n");
`	`return 0;
`	`}

`	`// программа-родитель
`	`wait(NULL);
`	`// ждем сигналов
`	`for(;;){
`		`pause();
`	`}	
`	`return 0;
}
```

Обе программы (родителя и потомка) зададим в одном файле. С одной стороны, это делает код более компактным, с другой – упрощает наследование за счет использования только *fork()* –вызова и позволяет потомку скопировать диспозицию родителя.

Ветвление происходит сразу же за вызовом fork(). Если он вернул 0, значит, выполняется код программы-сына, иначе — код программы отца.

Скомпилируем и выполним программу:
```c
dе@dе:~/lab4$ cc -o sigExam sigExam.c

dе@dе:~/lab4$ ./sigExam 

Father started: pid = 14589,ppid = 12231
Son started: pid = 14590,ppid = 14589
Successfully sent SIGUSR1
Catched signal SIGUSR1
Parent = 12231
```
Процесс-потомок отправил сигнал SIGUSR1, а процесс-отец его успешно принял. Отправим еще 3 сигнала процессу-отцу: SIGCHLD, SIGUSR2, SIGINT:
```c
dе@dе:~/lab4/sig$ kill -SIGUSR2 14589

dе@dе:~/lab4/sig$ kill -SIGCHLD 14589

dе@dе:~/lab4/sig$ kill -SIGINT 14589

Результат:
Catched signal SIGUSR2
Parent = 12231

de@de:~/lab4/sig$ 
```
Сигнал SIGUSR2 также был «пойман», на сигнал SIGCHLD не последовало никакой реакции (так как он был проигнорирован), и сигнал SIGINT привел к завершению работы.

Запустим программу еще раз и дважды отправим ей сигнал SIGUSR2:
```c
de@de:~/lab4/sig$ ./sigExam 

Father started: pid = 16225,ppid = 12231
Son started: pid = 16226,ppid = 16225
Successfully sent SIGUSR1
Catched signal SIGUSR1
Parent = 12231
Catched signal SIGUSR2
Parent = 12231
User defined signal 2
```
В результате первый сигнал был «пойман», второй обработался по умолчанию. Это происходит потому, что в обработчике прерываний после первого приема сигнала происходит восстановление диспозиции сигналов. Аналогичная ситуация была бы при двукратной отправке процессу сигнала SIGUSR1.

**Самостоятельно** 

повторите эксперимент для других сигналов и процессов, порождаемых в разных файлах; а также для потоков одного и разных процессов.

**Надежные сигналы**

**Пример.** 

ТЗ: Создать программу, позволяющую продемонстрировать возможность отложенной обработки (временного блокирования) сигнала (например, SIGINT). 

Вся необходимая для управления сигналами информация передается через указатель на структуру *sigaction*. Блокировку реализуем, вызвав "засыпание" процесса на одну минуту из обработчика пользовательских сигналов. В основной программе установим диспозицию этих сигналов. С рабочего терминала отправим процессу sigact сигнал SIGUSR1 или SIGUSR2, а затем сигнал SIGINT. 

**Исходный код** (sigact.c):
```c
#include <stdio.h>

#include <signal.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <unistd.h>

#include <stdlib.h>

#include <fcntl.h>

void (\*mysig(int sig,void (\*hnd)(int)))(int) {

`	`// надежная обработка сигналов

`	`struct sigaction act,oldact;

`	`act.sa\_handler = hnd;

`	`sigemptyset(&act.sa\_mask);

`	`sigaddset(&act.sa\_mask,SIGINT);

`	`act.sa\_flags = 0;

`	`if(sigaction(sig,&act,0) < 0)

`		`return SIG\_ERR;

`	`return act.sa\_handler;

}

void hndUSR1(int sig) {

`	`if(sig != SIGUSR1) {

`		`printf("Catched bad signal %d\n",sig);

`		`return;

`	`}

`	`printf("SIGUSR1 catched\n");

`	`sleep(60);

}

int main() {

`	`mysig(SIGUSR1,hndUSR1);

`	`for(;;) {

`		`pause();

`	`}

`	`return 0;

}
```
**Результаты выполнения**:
```c
de@de:~/lab4/sig$ cc -w -o sigact sigact.c

de@de:~/lab4/sig$ ./sigact &

[1] 25329

de@de:~/lab4/sig$ kill -SIGUSR1 %1

SIGUSR1 catched

de@de:~/lab4/sig$ kill -SIGINT %1

de@de:~/lab4/sig$ jobs

[1]+  Running                 ./sigact &

de@de:~/lab4/sig$ jobs

[1]+  Interrupt               ./sigact
```
Чтобы иметь возможность отправить сигналы с терминала следует запустить программу в фоновом режиме. По результатам сигнал SIGUSR1 принят корректно, но после посылки сигнала SIGINT программа продолжала выполняться еще минуту, и только после этого завершилась. В этом отличие надежной обработки сигналов от ненадежной: есть возможность отложить прием некоторых других сигналов. Отложенные таким образом сигналы записываются в маску PENDING и обрабатываются после завершения обработки сигналов, которые отложили обработку. Механизм ненадёжных сигналов не позволяет откладывать обработку других сигналов (можно лишь установить игнорирование некоторых сигналов на время обработки).

**Пример**

ТЗ: Изменить обработчик сигнала так, чтобы из него производилась отправка другого сигнала. 

Пусть из обработчика сигнала SIGUSR1 функцией kill() генерируется сигнал SIGINT. Проанализируем наличие и очередность обработки сигналов.

**Исходный код** программы:
```c
#include <stdio.h>

#include <signal.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <unistd.h>

#include <stdlib.h>

#include <fcntl.h>

void (\*mysig(int sig,void (\*hnd)(int)))(int) {

`	`// надежная обработка сигналов

`	`struct sigaction act,oldact;

`	`act.sa\_handler = hnd;

`	`sigemptyset(&act.sa\_mask);

`	`sigaddset(&act.sa\_mask,SIGINT);

`	`act.sa\_flags = 0;

`	`if(sigaction(sig,&act,0) < 0)

`		`return SIG\_ERR;

`	`return act.sa\_handler;

}

void hndUSR1(int sig) {

`	`if(sig != SIGUSR1) {

`		`printf("Catched bad signal %d\n",sig);

`		`return;

`	`}

`	`printf("SIGUSR1 catched, sending SIGINT\n");

`	`kill(getpid(),SIGINT);

`	`sleep(10);

}

int main() {

`	`mysig(SIGUSR1,hndUSR1);

`	`for(;;) {

`		`pause();

`	`}

`	`return 0;

}
```
**Результаты выполнения** программы:
```c
de@de:~/lab4/sig$ cc -w -o sigact2 sigact2.c

de@de:~/lab4/sig$ ./sigact2 &

[1] 28822

de@de:~/lab4/sig$ kill -SIGUSR1 %1

de@de:~/lab4/sig$ SIGUSR1 catched, sending SIGINT

jobs

[1]+  Running                 ./sigact2 &

de@de:~/lab4/sig$ jobs

[1]+  Running                 ./sigact2 &

de@de:~/lab4/sig$ kill -SIGINT %1

[1]+  Interrupt               ./sigact2
```
При генерации сигнала (в данном случае SIGINT) из обработчика другого сигнала обработка сгенерированного сигнала задерживается до конца выполнения текущего обработчика (как и в предыдущем эксперименте).

<a name="_toc190170008"></a>**Сигналы POSIX реального времени**

`	`Некоторые реализации POSIX ОС могут обрабатывать все сигналы как сигналы реального времени, но для UNIX-подобных ОС это не является обязательным. Если мы хотим, чтобы сигналы ***гарантированно*** обрабатывались как сигналы реального времени, мы должны: 

- использовать сигналы с номерами в диапазоне от SIGRTMIN до SIGRTMAX 
- должны указать флаг SA\_SIGINFO при вызове ***sigaction()*** с установкой обработчика сигнала
- обработчик сигнала реального времени, устанавливаемый с флагом SA\_SIGINFO, объявляется как:
- 
```c
  void func(int *signo,* siginfo\_t *\*info,* void *\*context*);   где

  *signo—* номер сигнала, 

  siginfo\_t — структура, определяемая как

  typedef struct {

  ` 	`int si\_signo; /\* то же, что и signo \*/

  `	`int si\_code; /\* SI\_{USER,QUEUE,TIMER,ASYNCIO,MESGQ} \*/

  ` 	`union sigval si\_value; /\* целое или указатель от отправителя \*/

  `	`} siginfo\_t;
```
  на что указывает *context* — зависит от реализации.

  Таким образом, сигналы реального времени несут больше информации, чем прочие сигналы (при отправке сигнала, не обрабатываемого как сигнал реального времени, единственным аргументом обработчика является номер сигнала).

- SIGRTMIN и SIGRTMAX – это еще и макросы  (вызывающие *sysconf*), которые позволяют изменять сами эти значения.

` `«**Характеристики сигналов реального времени**» означает следующее:

- Сигналы помещаются в очередь. 
- Если сигнал будет порожден несколько раз, он будет несколько раз получен адресатом. Более того, повторения одного и того же сигнала доставляются в порядке очереди (FIFO). Если же сигналы в очередь не помещаются, неоднократно порожденный сигнал будет получен лишь один раз.
- Когда в очередь помещается множество неблокируемых сигналов в диапазоне SIGRTMIN—SIGRTMAX, сигналы с меньшими номерами доставляются раньше сигналов с большими номерами. То есть сигнал с номером SIGRTMIN имеет «больший приоритет», чем сигнал с номером SIGRTMIN+1, и т.д.

**Самостоятельно**

1) проведите эксперимент, позволяющий определить возможность организации *очереди для различных типов сигналов,* обычных и реального времени,* (более двух сигналов, для этого увеличьте «вложенность» вызовов обработчиков);
1) экспериментально подтвердите, что обработка равноприоритетных сигналов реального времени происходит в порядке FIFO;
1) опытным путем подтвердите наличие приоритетов сигналов реального времени. 

`	`**Каналы**

Различают **два типа** каналов анонимные (иначе их называют «программные» или «неименованные») и именованные. Они по-разному реализованы, но доступ к ним организуется одинаково с помощью обычных функций read и write (унифицированный подход по типу *файловой модели*). Одним из свойств программных каналов и FIFO является то, что данные по ним передаются в виде потоков байтов (аналогично соединению TCP). Деление этого потока на самостоятельные записи полностью предоставляется приложению (в отличие, например, от очередей сообщений, которые автоматически расставляют границы между записями, аналогично тому, как это делается в дейтаграммах UDP). 

Рассмотрим оба типа каналов более детально с **примерами программ**.

<a name="_toc190170009"></a>**2. Неименованные каналы**

Программные (неименованные) каналы – однонаправленные, используются только для связи родственных процессов,  в принципе могут использоваться и неродственными процессами, если предоставить им возможность передавать друг другу дескрипторы (т.к. имен они не имеют). Неименованный канал создается посредством системного вызова pipe(2), который возвращает 2 файловых дескриптора filedes[1] для записи в канал и filedes[0] для чтения из канала: 
```c
#include

int pipe(int fd[2]);
```
/\* возвращает 0 в случае успешного завершения. –1 – в случае ошибки:\*/

Доступ к дескрипторам канала может получить как процесс, вызвавший *pipe()* , так и его дочерние процессы. Канал создается одним процессом, может использоваться им единолично (но редко). Как правило, это средство применяется для связи между двумя процессами, следующим образом: процесс создает канал, а затем вызывает *fork()*, создавая свою копию — дочерний процесс. Затем родительский процесс закрывает открытый для чтения конец канала, а дочерний, в свою очередь, — открытый на запись конец канала. Это обеспечивает одностороннюю передачу данных между процессами. При необходимости передачи данных в обе стороны нужно создавать пару каналов и использовать каждый из них для передачи данных в одну сторону. 

