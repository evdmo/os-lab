
Тренинг для начинающих 

Вводная лабораторная работа




по дисциплине "Операционные системы и среды"

**ИНТЕРПРЕТАТОРЫ КОМАНДНОЙ СТРОКИ ОС LINUX**

Цели работы:

1) Изучение основных команд пользовательского интерфейса

2) Изучение цикла подготовки и исполнения программ

3) Изучение команд и утилит обработки текстов

**Программа работы**

***I. Подготовка к работе.***

1\.  Установите ОС Linux на реальном компьютере или виртуальной машине (VM).

2\.  Для выполнения лабораторной работы рекомендуется использовать режим терминала. В этом режиме обработку командных строк осуществляет интерпретатор командной строки - shell.

3\. Создать файл отчета.
Создать файл можно переназначив вывод с экрана в файл.
```
$ >myfile.txt       (образуется пустой файл с именем myfile.txt).
```
В процессе работы Вам следует копировать в этот файл те фрагменты (сообщения, результаты выполнения команд, т.д.), которые Вы планируете представить в отчете.

Просмотр и редактирование файла отчета (равно как и любого другого текстового файла) можно производить в текстовых редакторах (как встроенных в графическую оболочку, так и вызываемых непосредственно из shell).

***II. Основы работы c командным интерфейсом.***

Единицей действия является команда. Значением команды служит код завершения.

Синтаксис команд в большинстве случаев имеет вид:

**имя\_команды  [флаги]  [аргументы]**  

Команда передается системе только после нажатия <Enter>, т.о. при неправильном наборе можно затереть один  или  несколько  символов с помощью клавиши DEL , или всю строку -- <^U>.

1\. Введите следующие информационные команды для получения полезных сведений об ОС и текущем сеансе:
```
date -- вывод текущей даты;

who  -- кто находится в системе;

who am i  ;

tty  -- полное имя файла-терминала;

logname -- входное имя;

uname  --  имя  UNIX-системы  ("имя компьютера")

lscpu – информация о процессорах/ядрах компьютера или виртуальной машины

lshw – информация о периферийном оборудовании
```
Прокомментируйте ответы системы.

3\. Справочное руководство

Используйте команду ' man '  для  получения справочной информации  о различных командах системы 
( 'man date' , 
'man who' , 
' man tty ' 
и т.д.  ).

Выявите общие правила построения справочников в ОС Linux (разделы и т.п.).

4\. Работа с файлами

a) Для получение информации о файлах из командной строки служит команда ls
Введя команду ls, получим (здесь и далее приведены примерные реакции системы):
```
$ ls
junk
temp
$
```
Эта команда  перечисляет имена существующих в вашем каталоге файлов.
Используя команду  ls  с ключом  -l, получим:
```
$ ls -l
total 2
rw-r--r--   1 buc      people        19 Aug 30 17:28 junk
rw-r--r--   1 buc      people        32 Aug 30 17:28 temp
$
```
Прокомментируйте результат.  Что будет,  если  ввести  'ls junk' ? 'ls junk temp' ?

b) Вывод содержимого файлов. Выведите содержимое имеющихся  у вас файлов с помощью команды cat :
```
$ cat junk
$ cat temp
$ cat junk temp
```
Что происходит, если cat получает несколько аргументов ?

c) Операции с файлами
Переименование файла осуществляется пересылкой его от одного имени к другому (mv -- move):
```
$ mv junk aaa
$ ls
aaa
temp
```
```
$ cat junk
cat: cannot open junk                 (junk`а уже нет)
$
```
Копирование файлов осуществляется с помощью команды cp:
```
$ cp aaa bbb
$ ls
aaa
bbb
temp
$
```
Удаляет файлы команда rm :
```
$ rm temp junk
rm: junk non-existent        (файла junk на существует)
$
```
```
$ rm aaa bbb
$ ls
$                             (никаких файлов нет)
```
Поинтересуйтесь в справочном руководстве работой  mv  , cp и rm .

5\. Работа с каталогами.

Определите полное имя вашего текущего  каталога с помощью  команды  pwd . Создайте произвольный файл  prog.c. Как по-вашему должно выглядеть полное имя файла prog.c ?

Введите ' ls <имя\_вашего\_каталога> '  .  Как  выводимые данные соотносятся с выводом "простой" команды 'ls'?  Введите  ,  'ls / ' , 'ls -l /' . Что можно сказать о содержимом каталога /bin ?

Перейдите в вышележащий каталог с помощью команды cd :

cd ..

Определите его полное имя и содержимое.
Поднимитесь еще "выше". Определите полное имя.
Поднимитесь еще "выше". Куда вы попали? Куда будете попадать, если продолжать это до бесконечности?

С помощью команды ls с ключами 'l' и 'd' ('ls -ld') определите владельцев каталогов / , /bin , и вашего домашнего каталога. Можете ли  вы изменить содержимое каталогов / или /bin?

Вернитесь в свой домашний каталог с помощью команды cd без аргументов. Проверьте результат.

Создайте в своем каталоге подкаталог командой mkdir :

mkdir  <имя\_каталога>

Перейдите в него ( cd <имя\_каталога> ). Нужно ли указывать  полное маршрутное имя для перехода? В каком случае это было бы необходимо ?
Скопируйте в новый каталог какой-либо файл из вышележащего (исходного) каталога:

cp ../prog.c  .

( '.' -- синоним текущего каталога, '..' -- вышележащего. В случае, если 2-й аргумент команды cp -- каталог, файл копируется в него под тем же именем. )
Вернитесь в вышележащий каталог. (Сколькими способами в данном случае это можно сделать? ). Выполните команду ls.
Попробуйте  удалить  свой  подкаталог с помощью команды rmdir  .  Каков  результат? Удалите файлы из этого каталога ( rm <имя>/prog.c ) и повторите попытку его  удаления.  Что получилось? (' ls ').

6\. Процессы ОС Linux

Введите команду ps -- информация о процессах, запущенных  с вашего терминала. Более полную информацию о процессах в системе предоставляет команда ps с ключом -A. Прокомментируйте полученную информацию, для чего обратитесь к справочному руководству.

***III. Изучение цикла подготовки и исполнения программ в ОС Linux.***

Язык С тесно связан с ОС UNIX,  т.к. первоначально был разработан именно для реализации ядра ОС. В первую очередь, он удобен для задач,  использующих системные вызовы, например, для управления памятью  и физическими устройствами, организации связи между процессами и т.д. Однако, С успешно применяется и для реализации программ,  не требующих такого непосредственного взаимодействия с ОС.  Цикл выполнения программ в UNIX аналогична большинству других ОС.
Файлы с исходными текстами С-программ должны иметь расширение '.с'. Команда вызова компилятора имеет следующий вид:

сс <имя\_программы>

При успешном исходе компиляции после нее будет выполнено  редактирование связей и сгенерирован выполняемый файл 'a.out'.  Для управления процессом компиляции и редактирования связей команда 'сс' имеет несколько опций, в том числе:
-с - подавляется фаза редактирования  связей. Генерируется объектный файл, который может быть использован для редактирования связей с помощью команды 'сс' без опции -с;
\- о <вых.файл> - выполняемый файл, полученный после редактирования связей, будет иметь имя <вых.файл>, а не 'a.out'.
Остальные опции, используемые командой 'сс', описаны в справочном руководстве.
Редактор связей объединяет несколько объектных файлов в один, выполняет настройку ссылок, включает процедуры инициализации и генерирует таблицу имен,  используемую отладчиком. Разумеется , можно выполнять редактирование связей и в случае единственного объектного файла. Результат редактирования по умолчанию помещается в файл 'a.out'. Команда 'ld' вызывает редактор связей непосредственно. Однако обычно эта команда не используется. Как правило, применяется команда запуска системы компиляции того или иного языка (например, 'сс', 'gcc', 'g++'), которая сама вызывает редактор связей.

Информация или управляющие параметры могут  передаваться в С-программу как  аргументы командной строки при запуске программы. При этом указанные в командной строке  аргументы  передаются функции main() через два ее параметра,  первый из которых содержит количество аргументов, а второй является массивом указателей на цепочки символов, содержащие передаваемую в качестве аргументов информацию (выполнение любой С-программы начинается с функции main()).  Обычно параметры функции main() имеют имена argc и argv, хотя это и не обязательно.  Argc - целое число, равное количеству передаваемых  аргументов.  Это  число всегда больше или равно 1, поскольку сама команда считывается первым аргументом, и arg[0] является  указателем на цепочку символов,  представляющую команду.

С помощью любого текстового редактора создайте файл prog.c, содержащий любой исходный текст С-программы.
```c
#include <stdio.h>
main ()
{
printf ("Hello, everybody ! ");
}
```
Создайте объектный  файл.  Определите, какое ему присвоено имя. Соберите исполняемый файл. Проанализируйте результат. Получите исполняемый  файл  с именем hello из файла с исходным текстом. Проверьте работоспособность полученных исполняемых  файлов. Переназначьте вывод программы в файл res. Проверьте результат.

Для изучения  передачи  информации  в  С-программы создайте файл с именем my\_open.с, содержащий исходный  текст  следующей С-программы.
```c
#include <stdio.h>
main ( argc, argv )
int argc;
char \*argv [];
{
if (argc > 1) {
`   `if (fopen(argv[1],"r") == NULL) {
printf("%s: неудача при попытке открыть файл %s",argv[0],argv[1]);
`  `else
printf("%s: файл %s открыт",argv[0],argv[1]);
}
else
`     `printf("открываемый файл не указан");
}
```
Создайте исполняемый файл. Исполните программу, передавая в качестве аргумента имя реально существующего файла  (предварительно создайте  его),  имя не существующего файла и не указывая никакого аргумента. Проанализируйте результаты.

В ОС UNIX есть возможность направлять выходной поток  одной программы на вход другой программы - организация конвейера. Откорректируйте первую программу, создав файл file\_name.c, таким образом, чтобы на печать выводилось имя файла (существующего или не существующего).  Получите исполняемую программу с именем file\_name. Попытайтесь организовать конвейер из двух созданных исполняемых программ командой:
```
file\_name||my\_open
```
а также другими командами:
```
file\_name|my\_open
file\_name&&my\_open
```
Проанализировав полученные результаты, уясните различие использованных типов команд, конвейеров. Если не удалось выполнить конвейер команд, исправьте тексты С-программ требуемым образом. В отчете представьте пояснения выполненным Вами действиям.

***IV. Изучение команд и утилит обработки текстов.***

Существует большое число команд  UNIX,  которые  читают входной поток,  выполняют  простые операции над ним и записывают результат в выходной поток.  Такие программы называются **фильтрами**. Многие команды могут быть фильтрами, поскольку обычно в случае, если не задан файл-аргумент, читается стандартный ввод.  Важной особенностью фильтров является то, что они никогда **не изменяют исходных файлов**, а лишь выводят *на стандартный вывод* обработанную информацию.  Стандартный вывод также можно *переназначить в файл*.

1\. G r e p - поиск по шаблону, заданному регулярным выражением

Команда grep имеет следующий синтаксис:

grep [опции] <шаблон> [файл ...]

Команда grep сопоставляет строки исходных файлов с шаблоном, заданным ограниченным регулярным выражением. Если файлы не указаны, используется стандартный ввод. Обычно каждая успешно сопоставленная строка копируется на стандартный вывод; если исходных файлов несколько,  перед найденной строкой  выдается  имя файла. В  качестве шаблонов воспринимаются ограниченные регулярные выражения - см. справочное руководство по команде 'grep'.
Для экранирования символов $,\*,[],^,!,() и \ от интерпретации shell проще всего заключать ограниченное регулярное выражение в одинарные кавычки.
Перечень опций команды также рекомендуется изучить, пользуясь справочным руководством.

Выведите только те строки из вывода ls -l /tmp, которые:
\1) соответствуют каталогам;
\2) соответствуют выполняемым для всех файлам;
\3) принадлежат пользователь root;
\4) не принадлежат пользователю root\.

2\. C u t  - выборка отдельных полей из строк файла

Команда cut имеет следующий синтаксис:

` `cut -cсписок [файл ...]

cut -fсписок [-dсимвол][-s][файл ...]

Команда cut используется для выборки колонок из таблицы или полей из каждой строки файла. Поля, специфицированные списком, могут быть фиксированной (опция -с) или переменной длины  (опция -f). В случае переменной длины поля границей поля является символ-разделитель (опция -d). По умолчанию разделителем  является символ табуляции. Значения опций следует уточнить по справочному руководству.

Определите с использованием команды cut:
\1) номера запущенных Вами процессов;
\2) идентификаторы пользователей,  имеющих  x-терминалы на Вашей рабочей станции;
\3) Ваше входное имя в системе\.

3\. T r  -  преобразователь символов

Команда tr имеет следующий синтаксис:

` `tr [опции] цепочка1 цепочка2

Команда tr копирует стандартный ввод на стандартный вывод с заменой либо удалением выбранных символов.  Символы, найденные в цепочке1,  заменяются  на  соответствующие  символы из цепочки2. Чтобы помещать в цепочки отрезки  алфавита,  можно  использовать сокращение: [c1-c2] -- цепочка символов, коды ASCII которых принадлежат отрезку от кода символа с1 до с2.

Выведите информацию о ваших файлах прописными буквами.

4\. S o r t - сортировка и / или слияние файлов

Команда sort имеет следующий синтаксис:

` `sort [опции] [файл...]

Команда sort сортирует строки,  входящие во все исходные файлы, и выдает результат на стандартный вывод. При упорядочении используется один или несколько ключей сортировки, выделяемых из каждой вводимой строки. По умолчанию ключ сортировки один - вся строка, а порядок является  лексикографическим,  соответствующим принятой кодировке символов. Опции, изменяющие стандартный порядок работы, изучите по справочному руководству.

Отсортируйте файлы в вашем каталоге (ls -l):
\1) в алфавитном порядке,
\2) в порядке увеличения размеров файлов,
\3) в порядке уменьшения размеров файлов\.

5\. U n i q  -  выдача информации о повторяющихся строках файла

Команда uniq имеет следующий синтаксис:

` `uniq [опции] [исходный файл [выходной файл]]

Команда uniq  читает  исходный  файл  и сравнивает соседние строки. В обычном режиме вторая и последующие копии повторяющейся строки исключаются;  остаток поступает в выходной файл, который не должен совпадать с исходным. Для того, чтобы повторяющиеся строки были соседними, файл надо отсортировать.

Выведите повторяющиеся размеры файлов из каталога /usr/bin. Для этого из вывода ls -l с помощью cut оставьте только размеры, отсортируйте полученный  поток  и  из результата выделите только повторения.

6\. C m p  - сравнение двух файлов

Команда cmp имеет следующий синтаксис:

` `cmp [опции] файл1 файл2

Команда cmp производит побайтное сравнение и прекращает работу при первом несовпадении.

Сравните файлы исходных текстов и объектные файлы созданных С-программ.

7\. D i f f  -  выявление различий между файлами

Команда diff имеет следующий синтаксис:

diff [опции] файл1 файл2

Команда diff выдает на стандартный вывод только те строки файлов, которые нужно изменить, чтобы привести файлы в соответствие друг с другом.

Сравните prog.c и my\_open.c с помощью diff:

diff -e prog.c my\_open.c > eqv

Проанализируйте содержимое eqv.

***V. Оформление отчетности***

Отредактировать и оформить отчет по лабораторной работе в виде log-файла, т.е. файла, журналирующего (фиксирующего) все ваши действия в терминале.

Создайте для себя **шаблон отчетного log-файла** и соблюдайте его для всех следующих лабораторных работ.

Обязательные позиции :

**Дата** исполнения отчета   (date)

Идентификация исполнителя (who, …), в комментариях указать **группу и  ФИО**

**Профиль системы:**

Описание аппаратуры/компьютера (lscpu, …)

Идентификация виртуальной машины **VM и ее настроек**, если установлена

Идентификация/описание ОС (uname, …)

Далее для каждой ЛР (лаб.работы) 

Указывается **пункт/подпункт задания** из соответствующего файла задания и

выводится вся **лог-информация при выполнении этого пункта** с комментариями, где это видится необходимым исполнителю.

**Шаблон оформления пункта**:

`	`Состояние системы до выполнения действия, указанного в задании,

`	`Действие

`	`Состояние системы после выполнения действия

`	`Сравнение состояний (например команда Diff для соответствующих файлов, описывающих состояние или изменение в системе)

`	`*Ключами утилит **всю выводимую информацию дополняйте временем и датой вывода!!!***

Комментарий, если требуется, завершающий анализ результатов по этому пункту

И так далее по каждому пункту файла-задания **с соблюдением нумерации пунктов,** указанной в файле-задании.

